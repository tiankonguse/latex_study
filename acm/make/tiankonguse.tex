\documentclass[a4paper]{article}

\usepackage{CJK} %设置中文包
\usepackage{listings}  % 用于代码插入
\usepackage{xcolor} % 用于配色
\usepackage[landscape,  margin=2cm, headsep=.3cm]{geometry}
\usepackage{graphicx} %使用图形
\usepackage{amsmath} %使用数学库
\usepackage{amssymb}
\usepackage{cmap}
\usepackage{slashbox}
\usepackage{float}
\usepackage{multicol} %设置多栏
\setlength{\columnseprule}{0.02cm} %设置栏之间的分隔线的宽度，0则不显示分隔线。
\setlength{\columnsep}{0.5cm} %设置栏之间的间隔。

\usepackage{indentfirst}

%\usepackage[dvips]{hyperref}
\usepackage{hyperref}
\hypersetup{%
	unicode=true,
	CJKbookmarks=true, 
	bookmarksnumbered=true,
	bookmarksopen=true, 
	bookmarksopenlevel=1, 
	breaklinks=true,
	colorlinks=false, 
	plainpages=false, 
	pdfpagelabels, 
	pdfborder=0 0 0,
	linktocpage=false,  
	linkcolor=black, 
	anchorcolor=black, 
	citecolor=black
}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancypagestyle{plain}{
  \pagestyle{fancy}
}

%对齐方式
%左对齐 \begin{flushleft}...\end{flushleft}搜索
%居中 \begin{center}...\end{center}
%右对齐 \begin{flushright}...\end{flushright}
%linespread 设置行距

%打印公式符号
% 打印 % => \%
% 打印 ^ => \^{}
% 打印 _ => \_
%     + => \#
%     $ => \$
%     { => \{
%     } => \}
%     ~ => \~ ,推荐 $\sim$
%     & => \&
%     ｜ => $｜$
%     < => $<$
%     > => $>$
%     * => $*$
%


%页眉和页脚的左部，中部，右部
\lhead{\thepage}
\chead{\textit{NENU CS ACM CODE}}
\rhead{\thepage}
\lfoot{\thepage}
\cfoot{make by \href{http://tiankonguse.com/}{tiankonguse} \& powered      by nenu CS acmer}
\rfoot{\thepage}
\renewcommand{\headrulewidth}{0.05cm}
\renewcommand{\footrulewidth}{0cm}

%定义一个名为 darkgreen 的颜色
\xdefinecolor{darkgreen}{rgb}{0,0.35,0}

%设置插入的代码的样式
\lstset{
    tabsize=4,%tab键用四个空格替换
    basicstyle=\ttfamily\scriptsize,
    extendedchars=false, %解决代码跨页时，章节标题，页眉等汉字不显示的问题
  	escapechar=`, %中文添加`后，可以避免注释中如果含有中文则顺序错乱
    breaklines=true,      %让LaTeX自动将长的代码行换行排版
    breakatwhitespace=false,
    language=C++,   %让LaTeX排版时将C++键字突出显示
    keywordstyle=\textbf, %for printing
    morekeywords={bool,__int64},
    keywordstyle=\color{blue!90},%关键词的颜色
    commentstyle=\color{darkgreen!85},%注释的颜色
    rulesepcolor=\color{red!20!green!20!blue!20},
    basicstyle=\footnotesize\ttfamily, %for paste
    columns=flexible,
%	showspaces=false,
%	showtabs=false,
%	numbers=left, 
%	numberstyle=\tiny,
%	frame=shadowbox, 
%	rulesepcolor=\color{red!20!green!20!blue!20},
    xrightmargin=0.5em %右边距
}

\title{ACM CODE}
\author{\href{http://tiankonguse.com/}{tiankonguse}}
\date{\today}

\begin{document}
%使用CJK中文 ，仿宋格式
\begin{CJK*}{UTF8}{gbsn}

%首页是封面，所以应该显示一栏
\begin{onecolumn}

\maketitle

%插入图片
\centering{\includegraphics[width=10cm]{front.eps}}

\end{onecolumn}

%新的一页
\clearpage

\center{this is a blank page.}

%新的一页
\clearpage

%设置多栏
\begin{multicols}{3}

%设置目录的名字
\renewcommand{\contentsname}{目录}

%生成目录
\tableofcontents

\clearpage 

%全部左对齐
\begin{flushleft} 

% 
% section{一级目录}
%
% 
%subsection{二级目录}
%
%\begin{lstlisting}[language={代码语言}]
% 插入代码
%  //`代码注释全部用这个引起来，防止因为中文引起顺序错乱`
%\end{lstlisting}
%
%lstinputlisting 可以程序导入文件
%
\section{Base}
\subsection{头文件}
%\cppcode{header.cpp}
\lstinputlisting[language={C++}]{source/base/header.cpp}

\subsection{文件结束符}
\lstinputlisting[language={C++}]{source/base/file_endsign.cpp}

\subsection{codeblock配置终端}
\lstinputlisting[language={C++}]{source/base/codeblock_setting.cpp}

\subsection{codeblock快捷键}
\lstinputlisting[language={C++}]{source/base/codeblock_shortcuts.cpp}

\subsection{通用long long}
\lstinputlisting[language={C++}]{source/base/normal_long_long.cpp}

\subsection{设置栈的大小}
\lstinputlisting[language={C++}]{source/base/set_stack_size.cpp}

\subsection{Faster\_IO(G++ is better)}
\lstinputlisting[language={C++}]{source/base/faster_io.cpp}


\subsection{Notes}
\lstinputlisting[language={C++}]{source/base/notes.cpp}



\clearpage 

\section{数据结构}

\subsection{数的范围}
\lstinputlisting[language={C++}]{source/dataStructure/number_range.cpp}

\subsection{素数专题}
素数定理：pi(x)/x*ln(x)=1,pi(x)表示小于x的素数的个数
孪生素数猜想:存在无穷个p,p+2的素数对
PS：陈景润证明的存在无穷个素数p，p+2至多有两个素数因子，及传说当中的"1+2"问题
哥德巴赫猜想:每个大于2的偶数是两个素数的和
$n^2+1$猜想:存在无穷个$n^2+1$这样形式的素数
埃拉托斯尼斯筛法：正整数n是素数，当且仅当它不能被任何小于n的平方根的素数整除。
有时候素数的范围很大，不能把所有的素数表打出来，就要只存部分素数。 
如果求区间的素数，就对区间进行筛法



\subsubsection{素数定理}
对正实数x，定义π(x)为素数计数函数，亦即不大于x的素数个数。
简单表达式：$\pi(x)\approx\frac{x}{\ln\,x}$,其中ln x为x的自然对数。
精确表达式：$\pi(x)={\rm Li} (x) + O \left(x e^{-\frac{1}{15}\sqrt{\ln\,x}}\right)$,其中 ${\rm Li} (x) = \int_2^x \frac{dt}{\ln\,t}$

\subsubsection{素数表基本晒法}
\lstinputlisting[language={C++}]{source/dataStructure/sieve_base_prime.cpp}

\subsubsection{压位筛素数}
\lstinputlisting[language={C++}]{source/dataStructure/sieve_bit_prime.cpp}

\subsubsection{sieve}
\lstinputlisting[language={C++}]{source/dataStructure/sieve_mark_prime.cpp}

\subsubsection{小舟学长的筛法}
\lstinputlisting[language={C++}]{source/dataStructure/sieve_vici_prime.cpp}

\subsubsection{区间素数}
\lstinputlisting[language={C++}]{source/dataStructure/sieve_range_prime.cpp}

\subsubsection{sieve 100000 primes $>$ 1e12}
\lstinputlisting[language={C++}]{source/dataStructure/sieve_large_prime.cpp}

\subsubsection{反素数}
\lstinputlisting[language={C++}]{source/dataStructure/anti_prime.cpp}



\subsection{大素数}
\lstinputlisting[language={C++}]{source/dataStructure/huge_prime.cpp}



\subsubsection{检验n是不是合数}
\lstinputlisting[language={C++}]{source/dataStructure/huge_prime_check_composite.cpp}



\subsubsection{大素数测试}
\lstinputlisting[language={C++}]{source/dataStructure/huge_prime_test.cpp}

\subsubsection{pollard\_rho分解}
\lstinputlisting[language={C++}]{source/dataStructure/pollard_rho.cpp}


\subsubsection{质因数分解N }
\lstinputlisting[language={C++}]{source/dataStructure/huge_prime_find.cpp}

\subsection{梅森素数}
m是一个素数，$M=2^m-1$也是一个素数，则M是梅森素数。
使用大素数测试得到森素数。

\subsubsection{Lucas-Lehmer判定法}
\lstinputlisting[language={C++}]{source/dataStructure/lucas_lehmer.cpp}

\subsection{同余}
两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余
记作$a \equiv b \pmod{m}$


\subsection{费马大定理}
当整数n>2时，关于x, y, z的不定方程 $x^n + y^n =z^n$.的整数解都是平凡解
当n是偶数时：$(0,\pm m,\pm m)$或$(\pm m,0,\pm m)$
当n是奇数时：$(0,m,m), (m,0,m)$或$(m,-m,0)$



\subsection{费马小定理}
如果p是素数，则$a^{p-1} \equiv  1 \pmod{p}$对所有整数a都成立


\subsection{欧拉函数}

\subsubsection{欧拉定理}
$a^{\varphi(n)} \equiv 1 \pmod n, \gcd(a,n)=1$

\subsubsection{一些结论}
a为N的质因数
若 (N/a)\%a == 0 则有 E(N) = E(N/a)*a.
若 (N/a)\%a !=0则有 E(N) = E(N/a)*(a-1)
一个数的所有质因子之和 F（n）*n/2.


\subsubsection{原根}
在gcd(a,m)=1时，定义a对模m的指数$Ord_m(a)$为使$a^d \equiv 1 \pmod{m}$成立的最小的正整数d。
由前知$Ord_m(a) $一定小于等于$  \phi (m)$，若$Ord_m (a) = \phi (m)$，则称a是模m的原根。
设m是正整数,a是整数,若a模m的阶等于φ(m),则称a为模m的一个原根

\lstinputlisting[language={C++}]{source/dataStructure/primitive_root.cpp}


\subsubsection{与n互素的数的和}
$\sum_{1\le k\le n \atop (k,n)=1}\!\!k = \frac{1}{2}n\varphi(n)\text{ for }n>1$


\subsubsection{第n个与m互质的数}
如果求与m互质的第n个数，可以先把小于m的互质的数错在ans中（筛法求）
（从1开始存，最后一个存在0中），然后大于m的互质的数都是小于m的互质的数加上若干个m得到的。

\lstinputlisting[language={C++}]{source/dataStructure/nth_prime.cpp}

\subsection{sieve phi}
\lstinputlisting[language={C++}]{source/dataStructure/sieve_phi.cpp}

\subsubsection{打表欧拉函数}
\lstinputlisting[language={C++}]{source/dataStructure/phi_tanle.cpp}


\subsubsection{单独求欧拉函数(公式)}
\lstinputlisting[language={C++}]{source/dataStructure/phi_single.cpp}

\subsubsection{容斥求小于a的与n互质的个数}
\lstinputlisting[language={C++}]{source/dataStructure/phi_kth.cpp}

\subsection{随机数}
\lstinputlisting[language={C++}]{source/dataStructure/rand_number.cpp}

\subsection{二分}

\subsubsection{最大值最小化问题}
m个正整数的序列划分成m个子连续序列，每个子序列的个数字之和为S, 使所有S中的最大S最小。\\

\subsubsection{数轴上点到点的距离和}
点的中位数就是答案\\
如果点有奇数个，答案唯一。\\
如果点有偶数个，答案是个区间\\

\subsubsection{数轴上点到点的距离平方和}
列出方程后，可以证明是个凸函数。\\
于是这个可以使用三分做。\\
猜想可能还是中位数。\\

\subsubsection{坐标系上点到点的曼哈顿距离和}
此时，x轴与y轴没有关系了，找到x轴的中位数与y轴的中位数即可。\\

\subsubsection{...到点的距离平方和}
这个经过列出等式后，可以发现，每一维是相互独立的。\\
而转化成了在数轴上的距离平方和问题了。\\

\subsubsection{...到点的距离和}
这个需要偏导数理论。\\
写出偏导数后发现当其他维数固定时，这个维数还是相互独立的。\\
但是不使用偏导数时，我们只需使用变步长寻找即可。\\
例如：\\
1. 取步长为step，起点为(x0,y0)\\
2. 我们找到上下左右的四个点的值，如果有比(x0,y0)更优的值，则更新(x0,y0)。\\
3. 循环执行步骤2，直到(x0,y0)就是最优值。\\
4. 此时，步长变为原来的0.5倍，继续执行步骤2.直到step达到一定的精度。\\

\subsubsection{...到直线的距离和}
思考中\\


\subsubsection{...到直线的距离平方和}
思考中\\



\subsection{贪心}

\subsubsection{区间选点问题}
取尽量少的点，使每个区间内都至少有一个点。\\

\subsubsection{区间覆盖问题}
数轴上有若干区间，选尽量少的区间，覆盖指定区间。\\


\subsection{GCD}


\subsubsection{GCD(无递归)}
\lstinputlisting[language={C++}]{source/dataStructure/gcd_noRecursion.cpp}



\subsubsection{GCD(递归)}
\lstinputlisting[language={C++}]{source/dataStructure/gcd_recursion.cpp}

\subsubsection{快速GCD}
\lstinputlisting[language={C++}]{source/dataStructure/gcd_fast.cpp}

\subsubsection{fgcd}
\lstinputlisting[language={C++}]{source/dataStructure/gcd_float.cpp}


\subsubsection{GCD结论}
有俩个数p,q,且gcd(q,p)=1,则最大无法表示成px+qy（x>=0,y>=0)的数是pq-q-p.\\

\subsubsection{区间内与n的gcd不小于m的个数 }
输入m, n,求1~n之间中gcd(x, n) >=m 的x个数。\\
\\
找出N的所有大于等于M的因子(x1,x2,x3.....xi)，然后设k=N/xi；\\
下面只需找出小于k且与k互质的数。\\
因为：设y与k互质且小于k，那么gcd（y*xi，k*xi）=xi；（xi为N的因子，且xi大于等于M）。\\

\subsubsection{LCM}
\lstinputlisting[language={C++}]{source/dataStructure/lcm.cpp}


\subsection{扩展GCD}
\lstinputlisting[language={C++}]{source/dataStructure/kgcd.cpp}


\subsubsection{解不定方程ax + by =n}
（1）计算gcd(a,b)\\
若d=gcd(a,b)不能整除n,则方程无整数解；\\
否则，在方程的两边同除以gcd(a,b)，得到新的不定方程a'x+b'y=n',此时gcd(a' ,b')=1。\\
\\
（2） 求出不定方程a'x+b'y=1的一组整数解x0,y0，则n'x0,n'y0是方程a'x+b'y=n'的一组整数解。（用扩展欧几里得求x0,y0）\\
\\
（3）可得方程a'x+b'y=n'的所有整数解为：x=n'x+b't;y=n'y0-a't(t为整数)\\
这就是方程ax+by=n的所有整数解\\
x,y是通解\\
x=n/d*x0+b/d*t\\
y=n/d*y0-a/d*t\\
(t是整数) \\



\subsubsection{求(a/b)\% c(乘法逆元)}
\lstinputlisting[language={C++}]{source/dataStructure/inverse.cpp}




\subsubsection{模线性方程 a*x=b(mod n)}
\lstinputlisting[language={C++}]{source/dataStructure/linear_equations.cpp}


\subsection{因子}
\subsubsection{所有数的因子的个数 O(n*log(n))}
\lstinputlisting[language={C++}]{source/dataStructure/number_of_factor_all_number.cpp}


\subsubsection{所有数的因子的个数 O(n)}
\lstinputlisting[language={C++}]{source/dataStructure/number_of_factor_all_number_line.cpp}


\subsubsection{一个数的因子的个数}
\lstinputlisting[language={C++}]{source/dataStructure/number_of_factor_a_number.cpp}

\subsubsection{一个数的所有因子之和}
\lstinputlisting[language={C++}]{source/dataStructure/sum_of_factor_a_number.cpp}

\subsection{MOD}
\lstinputlisting[language={C++}]{source/dataStructure/mode.cpp}
 
\subsubsection{(a*b)\%c  muti\_mod1}
\lstinputlisting[language={C++}]{source/dataStructure/muti_mod.cpp}

\subsubsection{(a*b)\%c  muti\_mod2}
\lstinputlisting[language={C++}]{source/dataStructure/muti_mod2.cpp}

\subsubsection{$a^b\%c$ pow\_mod1}
\lstinputlisting[language={C++}]{source/dataStructure/pow_mod1.cpp}

\subsubsection{powMod}
\lstinputlisting[language={C++}]{source/dataStructure/pow_mod2.cpp}

\subsubsection{powMod\_plus}
\lstinputlisting[language={C++}]{source/dataStructure/pow_mod_plus.cpp}

\subsubsection{$x^{n}\%c$ 非递归版}
\lstinputlisting[language={C++}]{source/dataStructure/pow_mod_nonrecursive.cpp}

\subsubsection{求$a^{b}\%c$ 二进制思想}
\lstinputlisting[language={C++}]{source/dataStructure/pow_mod_binary.cpp}

\subsubsection{Lucas定理 求C(n+m,n)\%p}
\lstinputlisting[language={C++}]{source/dataStructure/lucas.cpp}

\subsubsection{C(n,m)\%mod (div)}
\lstinputlisting[language={C++}]{source/dataStructure/lucas_div.cpp}

\subsubsection{C(n,m)\%mod (inv)}
\lstinputlisting[language={C++}]{source/dataStructure/lucas_inv.cpp}

\subsubsection{迭代幂}
\lstinputlisting[language={C++}]{source/dataStructure/power_iterative.cpp}

\subsubsection{$A^x \% C =  = B$ (by ac)}
\lstinputlisting[language={C++}]{source/dataStructure/baby_step.cpp}

\subsection{汉若塔问题}
\lstinputlisting[language={C++}]{source/dataStructure/tower_of_hanoi.cpp}


\subsection{字母大小写转换 位操作}
\begin{lstlisting}[language={c++}]
'A'^'a' = 32; 
\end{lstlisting}

$$$$
\subsection{二项式展开}
$$(a+b)^n = \sum_{k=0}^n C_n^ka^{n-k}b^k$$\\


\subsection{阶乘}

\subsubsection{阶乘的位数（仅有位数）}
\lstinputlisting[language={C++}]{source/dataStructure/factorial_bits.cpp}


\subsubsection{阶乘0的个数}
\lstinputlisting[language={C++}]{source/dataStructure/factorial_zero_number.cpp}


\subsubsection{阶乘最后非0位}
\lstinputlisting[language={C++}]{source/dataStructure/factorial_last_nozero.cpp}


\subsubsection{阶乘分解}
\lstinputlisting[language={C++}]{source/dataStructure/factorial_number_of_factor.cpp}


\subsubsection{阶乘的位数（求各位数字）}
高精度乘法\\


\subsubsection{阶乘素数因子个数}
\lstinputlisting[language={C++}]{source/dataStructure/factorial_number_of_factor2.cpp}

\subsection{乘方$a^k$}
\subsubsection{快速乘方($a^k$)}
\lstinputlisting[language={C++}]{source/dataStructure/pow_fast.cpp}


\subsubsection{$A^B$次方的首位数字}
\lstinputlisting[language={C++}]{source/dataStructure/pow_first.cpp}



\subsection{二进制中一的个数}

\subsubsection{自底向上分治法O(5)}
\lstinputlisting[language={C++}]{source/dataStructure/bit_of_number_divide.cpp}


\subsubsection{复杂度为1的个数}
\lstinputlisting[language={C++}]{source/dataStructure/bit_of_number_xor.cpp}


\subsubsection{朴素的算法O(32)}
\lstinputlisting[language={C++}]{source/dataStructure/bit_of_number_line.cpp}

\subsection{树根}
\begin{lstlisting}
root(a+b)=root(root(a) + root(b)) 
root(a*b)=root(root(a) * root(b)) 
root(a)=root(root(a/10) + a%10)
\end{lstlisting}

\subsubsection{n的树根 模拟}
\lstinputlisting[language={C++}]{source/dataStructure/root_number_simulation.cpp}

\subsubsection{n的树根 找规律}
\lstinputlisting[language={C++}]{source/dataStructure/root_number_pattern.cpp}

\subsubsection{n的树根 高精度}
\lstinputlisting[language={C++}]{source/dataStructure/root_number_precision.cpp}

\subsubsection{$n^n$的树根 找规律}
\lstinputlisting[language={C++}]{source/dataStructure/pow_root_pattern.cpp}

\subsubsection{$n^n$的树根 模拟}
\lstinputlisting[language={C++}]{source/dataStructure/pow_root_simulation.cpp}

\subsubsection{$a^b$的树根 模拟}
\lstinputlisting[language={C++}]{source/dataStructure/pow_root_simulation2.cpp}

\subsubsection{$a^b$的树根 二进制法}
\lstinputlisting[language={C++}]{source/dataStructure/pow_root_binary.cpp}

\subsection{公式}

\subsubsection{三角公式}
Atan2(x,y):结果是以弧度表示(-PI，PI)\\
Atan2(0,-1)=PI\\

\subsubsection{数学公式}
sum(k)=(n+1)*n/2\\
sum(k\^{}2)=n (n+1)(2n+1)/6\\
sum(k\^{}3)=(n (n+1)/2)\^{}2\\
sum(k\^{}4)=n (n+1) (2n+1) （3n\^{}2+3n-1）/30\\
sum(k\^{}5)= n\^{}2 (n+1)\^{}2 (2n\^{}2+2n-1)/12\\
sum(k(k+1))=n(n+1)(n+2)/3\\
sum(k(k+1)(k+2))=n(n+1)(n+2)(n+3)/4\\
sum(k(k+1)(k+2)(k+3))=n(n+1)(n+2)(n+3)(n+4)/5\\

\subsubsection{精度公式}
\lstinputlisting[language={C++}]{source/dataStructure/high_double.cpp}

\subsubsection{对数公式}
\begin{lstlisting}
`$log_a^n + log_a^m = log_{a}^{nm} $`
`$k*log_a^n = log_{a}^{n^k}$ `
`换底公式： $log_a^n/log_b^n=log_b^a $`
\end{lstlisting}

\subsubsection{复杂度公式}
\begin{lstlisting}
`递归式T(n) = aT(n/b) + f(n)`
`递归树结果`
`$T(n) = f(n)+af(n/b)+a^2f(n/b^2)+…+a^Lf(n/b^L)$其中$L=log_bn $`
\end{lstlisting}

\subsection{微积分}

\subsubsection{曲线长度}
\begin{lstlisting}
`在y=f(x)的任意点(x,y)附近去一段小曲线，看成线段，其长度：`
Ds = sqrt(dx^2 + dy^2) 
= dx sqrt(1 + (dy/dx)^2 )
= sqrt(1 + f’(x)^2 ) dx
`所以：`s = sqrt(1 + f’(x)^2) [x2,x1]
\end{lstlisting}

\subsubsection{二次函数}
\begin{lstlisting}
`对于抛物线一般式：`y=ax^2 + bx + c, y’ = 2ax + b
ds = sqrt(1 + f’(x)^2)
 = sqrt(1 + (2ax + b)^2)dx 
 = 1/2a * sqrt(1 + (2ax+b)^2) d(2ax+b)
 = 1/2a * sqrt(1 + t^2) dt
 = 1/4a * (t * sqrt(1 + t^2) + ln(t + sqrt(1 + t^2))) [x2,x1]
\end{lstlisting}

\subsection{约瑟夫环的数学方法}
\lstinputlisting[language={C++}]{source/dataStructure/joseph_math.cpp}

\subsubsection{pick定理}
如果顶点都为整数坐标点，面积=边点/2+内点-1\\

\subsection{catalan数}
卡特兰数前几项
1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324 

\subsubsection{等价公式}
\begin{lstlisting}
h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0) (n>=2)
h(n)=h(n-1)*(4*n-2)/(n+1)
h(n)=C(2n,n)/(n+1) (n=1,2,3,...)
h(n)=c(2n,n)-c(2n,n+1)(n=1,2,3,...)
H(n+1) = 2(2n+1)/(n+2) * H(n)
H(n+1)=sum(H(i)*H(n-i)) (0<=i<=n)
H(n) = sum( C(n,i) * C(n,i) ) /(n+1) (0<=i<=n)
H(n) = 4^n/(n^1.5 * sqrt(pi))
\end{lstlisting}

\subsubsection{应用}
\begin{lstlisting}
`1.n个数的不同出栈序列`
`2.N个+1和n个-1构成2n项a1a2...an，其部分和满足a1+a2+a3+...+an>=0，0<=k<=2n。满足这个序列的个数等于第n个catakan数。`
`3.括号匹配的合法个数`
`4.连乘的选择个数`
`5.n个节点的二叉树的树的形态的个数。`
`6.n个非叶子节点的满二叉树的形态数。`
`7.n*n的矩阵中，从右下角到左上角的走法。`
`8.凸n+2边形进行三角分割数。`
`9.n层的阶梯切割为n个矩阵的切割法数。`
`10.在一个2*n的格子中填入1到2n这些数字，使每个格子内的数值都比其右边和上边的所有数值都小的情况数。`
\end{lstlisting}

\subsection{随机函数}
\lstinputlisting[language={C++}]{source/dataStructure/rands.cpp}

\subsection{积性函数}
对于正整数n的一个函数f(n),当中f(1)=1且当a,b互质时，f(a,b)=f(a) * f(b);\\
若某函数f(n)富符合f(1)=1,且就算a,b不互质,f(a,b)=f(a) * f(b),则称它为完全积性函数。\\

积性函数有：\\
欧拉函数：计算与n互质的小于n的正整数的个数\\
莫比乌斯函数:关于非平方数的质数因子的数目\\
gcd(n,k)：最大公因子,k固定\\
d(n):n的正因子数目，n的所有正因子之和\\

\subsection{三分算法}
\lstinputlisting[language={C++}]{source/dataStructure/third_div.cpp}

\subsection{位操作}

\subsubsection{与操作 \&}
i. 用以取出一个数的某些二进制位\\
ii. 取出一个数二进制中的最后一个 1：x\&-x

\subsubsection{或操作 $|$}
用以将一个数的某些位设为1\\

\subsubsection{非操作 $\sim$ }
用以间接构造一些数：$\sim$0u=4294967295=$23^2$-1\\
INI\_MAX = ($\sim$0u)$>$$>$1\\


\subsubsection{异或操作 \^{}}
i. 不使用中间变量交换两个数：a=a\^{}b;b=a\^{}b;a=a\^{}b; \\
ii. 将一个数的某些位取反\\



\subsection{矩阵}
\lstinputlisting[language={C++}]{source/dataStructure/matrix.cpp}


\subsubsection{矩阵相乘}
\lstinputlisting[language={C++}]{source/dataStructure/matrix_mul.cpp}

\subsubsection{矩阵幂乘}
\lstinputlisting[language={C++}]{source/dataStructure/matrix_pow.cpp}

\subsubsection{判断A*B==C 随机算法}
\lstinputlisting[language={C++}]{source/dataStructure/matrix_eq_rand.cpp}

\subsubsection{判断A*B==C 伪随机算法}
A*B的复杂度是O($n^3$)，A是一维的话，复杂度就是O($n^2$)了。\\
所以A*B == C 可以近似的转化为1 * A * B == 1 * C\\
1是一维的向量。\\

\subsubsection{矩阵幂相加}
给定矩阵A，求$A + A^2 + A^3 + ... + A^k$的结果（两个矩阵相加就是对应位置分别相加）。输出的数据mod m。$k<=10^9$。\\
这道题两次二分，相当经典。\\
首先我们知道，$A^i$可以二分求出。\\
然后我们需要对整个题目的数据规模k进行二分。\\
比如，当k=6时，有：$A + A^2 + A^3 + A^4 + A^5 + A^6 =(A + A^2 + A^3) + A^3*(A + A^2 + A^3)$\\
应用这个式子后，规模k减小了一半。\\
我们二分求出$A^3$后再递归地计算$A + A^2 + A^3$，即可得到原问题的答案。\\

\subsection{构造矩阵}

\subsubsection{求第 n 个 Fibonacci 数 mod p}
给定 n 和 p，求第 n 个 Fibonacci 数 mod p 的值，n 不超过 2\^{}31\\
现在我们需要构造一个 2 x 2 的矩阵，使得它乘以(a,b)得到的结果是(b,a+b)。\\
每多乘一次这个矩阵，这两个数就会多迭代一次。\\
那么，我们把这个 2 x 2 的矩阵自乘 n 次，再乘以(0,1)就可以得到第 n 个 Fibonacci 数了。\\
不用多想，这个 2 x 2 的矩阵很容易构造出来：\\

\begin{pmatrix}
	0 & 1  \\
    1 & 1
\end{pmatrix}
\cdot
\begin{pmatrix}
	a  \\
    b 
\end{pmatrix}
=
\begin{pmatrix}
	b  \\
    a+b 
\end{pmatrix}

\subsubsection{A 走 k 步到 B 的方案数}
给定一个有向图，问从 A 点恰好走 k 步（允许重复经过边）到达 B 点的方案数 mod p 的值\\
把给定的图转为邻接矩阵，即 A(i,j)=1 当且仅当存在一条边 i->j。\\
令 C=A*A，那么C(i,j)=ΣA(i,k)*A(k,j)，实际上就等于从点 i 到点 j 恰好经过 2 条边的路径数（枚举 k 为中转点）。\\
类似地，C*A 的第 i 行第 j 列就表示从 i 到 j 经过 3 条边的路径数。\\
同理，如果要求经过 k 步的路径数，我们只需要二分求出 A\^{}k 即可。\\

\subsubsection{用1x2填充MxN的矩阵}
用 1 x 2 的多米诺骨牌填满 M x N 的矩形有多少种方案，M$<$=5，N$<$2\^{}31，输出答案 mod p 的结果\\

\subsection{高斯消元法}
\lstinputlisting[language={C++}]{source/dataStructure/gauss.cpp}

\subsection{母函数}
\subsubsection{母函数（整数拆分）}
\lstinputlisting[language={C++}]{source/dataStructure/generating_function_integer_split.cpp}

\subsubsection{指数型母函数}
\lstinputlisting[language={C++}]{source/dataStructure/generating_function_index.cpp}

\subsection{约瑟夫问题}
\lstinputlisting[language={C++}]{source/dataStructure/joseph.cpp}

\subsection{汉诺塔升级版}
\lstinputlisting[language={C++}]{source/dataStructure/tower_of_hanoi_upgrade.cpp}

\subsection{快速排序}
\lstinputlisting[language={C++}]{source/dataStructure/quick_sort.cpp}

\subsection{堆}
\lstinputlisting[language={C++}]{source/dataStructure/heap.cpp}

\subsection{最大堆}
\lstinputlisting[language={C++}]{source/dataStructure/heap_max.cpp}

\subsection{堆排序}
\lstinputlisting[language={C++}]{source/dataStructure/heap_sort.cpp}

\subsection{归并排序求逆序数}
\lstinputlisting[language={C++}]{source/dataStructure/reverse_number_by_merger_sort.cpp}

\subsection{取第 k 个元素}
\lstinputlisting[language={C++}]{source/dataStructure/number_kth.cpp}

\subsection{Pell 方程}
\lstinputlisting[language={C++}]{source/dataStructure/pell.cpp}

\subsection{区间合并}
可以先对区间排序；然后简单合并即可\\

\subsection{星期几}
\lstinputlisting[language={C++}]{source/dataStructure/week.cpp}

\subsection{线段树}

\subsubsection{单点更新}
\lstinputlisting[language={C++}]{source/dataStructure/segment_tree_single_point.cpp}

\subsubsection{成段更新}
\lstinputlisting[language={C++}]{source/dataStructure/segment_tree_segments.cpp}


\subsubsection{应用}
\lstinputlisting[language={C++}]{source/dataStructure/segment_tree_application.cpp}

\subsection{树套树}
\subsubsection{线段树套平衡树}
\lstinputlisting[language={C++}]{source/dataStructure/segment_tree_cover_balanced_tree.cpp}

\subsubsection{划分树}
\lstinputlisting[language={C++}]{source/dataStructure/partition_tree.cpp}

\subsection{左偏树}
\lstinputlisting[language={C++}]{source/dataStructure/left_side_tree.cpp}

\subsection{DLX}
\lstinputlisting[language={C++}]{source/dataStructure/dlx.cpp}

\subsection{AC 自动机}
\lstinputlisting[language={C++}]{source/dataStructure/AC_automaton.cpp}

\subsubsection{传统字典树}
\lstinputlisting[language={C++}]{source/dataStructure/AC_automaton_trie.cpp}

\subsubsection{数组式字典树}
\lstinputlisting[language={C++}]{source/dataStructure/AC_automaton_array.cpp}


\subsection{最少交换次数}

\subsubsection{只能交换相邻的数}
\begin{lstlisting}
`给出一组数，通过不断交换两个相邻的数，可以使这组数按非递减顺序排列。问，最小的交换次数是多少？\\
思路：归并排序，其实答案就是逆序数的个数。`
\end{lstlisting}

\subsection{只能交换相邻的区间}
\begin{lstlisting}
`使用 IDA*搜索。`
\end{lstlisting}


\subsection{离散化}
\lstinputlisting[language={C++}]{source/dataStructure/discrete.cpp}

\subsection{Splay（伸展树）}
\lstinputlisting[language={C++}]{source/dataStructure/splay.cpp}

\subsection{分段哈希}
\lstinputlisting[language={C++}]{source/dataStructure/break_hash.cpp}

\subsection{树状数组}
\lstinputlisting[language={C++}]{source/dataStructure/tree_array.cpp}

\subsubsection{一维情况}
\lstinputlisting[language={C++}]{source/dataStructure/tree_array_one_dimensional.cpp}



\subsubsection{二维情况}
\lstinputlisting[language={C++}]{source/dataStructure/tree_array_two_dimensional.cpp}

\subsection{Treap 树}
\lstinputlisting[language={C++}]{source/dataStructure/treap.cpp}

\subsection{HarmonicNumber (by rejudge)}
\lstinputlisting[language={C++}]{source/dataStructure/harmonic_number.cpp}

\subsection{Gauss int (Enumrate the arguments)}
\lstinputlisting[language={C++}]{source/dataStructure/gauss_int.cpp}

\subsection{Gauss (mod)}
\lstinputlisting[language={C++}]{source/dataStructure/gauss_mod.cpp}

\subsection{Gauss (double)}
\lstinputlisting[language={C++}]{source/dataStructure/gauss_double.cpp}

\subsection{Gauss (Linear Base)}
\lstinputlisting[language={C++}]{source/dataStructure/gauss_linear_base.cpp}



\section{DP}

\subsection{DP 分类}
\lstinputlisting[language={C++}]{source/dp/dp_class.cpp}

\subsection{单调队列}
\lstinputlisting[language={C++}]{source/dp/monotonous_queue.cpp}

\subsection{排列组合}
\lstinputlisting[language={C++}]{source/dp/permutations_and_combinations.cpp}


\subsection{组合 C（m,n）}
\lstinputlisting[language={C++}]{source/dp/combinations.cpp}

\subsection{有 n 种物品，并且知道每种物品的数量}
\lstinputlisting[language={C++}]{source/dp/balls_and_the_number_of_ball.cpp}

\subsubsection{选出 m 件物品的排列数}
\lstinputlisting[language={C++}]{source/dp/permutations_choose_balls.cpp}

\subsubsection{选出 m 件物品的组合数}
\lstinputlisting[language={C++}]{source/dp/combinations_choose_balls.cpp}

\subsection{错排}
\lstinputlisting[language={C++}]{source/dp/staggered.cpp}

\subsection{整数拆分}
\lstinputlisting[language={C++}]{source/dp/integer_split.cpp}

\subsection{球与盒子}
\begin{lstlisting}
`n个球 m个盒子`
\end{lstlisting}

\subsubsection{Place $n$ Balls into $m$ Boxes}
\begin{table}[h]
\scriptsize
    \begin{tabular}{|c|c|c|l|}
        \hline
        Balls & Boxes & Empty Boxes & Answer \\ \hline
        Different & Different & Yes & $m^n$ \\ \hline
        Different & Different & No & $m!S\left( {n,m} \right)$ \\ \hline
        Different & Same & Yes & $S\left( {n,1} \right) + S\left( {n,2} \right) +  \ldots  + S\left( {n,\min \left( {n,m} \right)} \right)$ \\ \hline
        Different & Same & No & $S\left( {n,m} \right)$ \\ \hline
        Same & Different & Yes & $C\left( {n + m - 1,n} \right)$ \\ \hline
        Same & Different & No & $C\left( {n - 1,m - 1} \right)$ \\ \hline
        Same & Same & Yes & $F\left( {n,m} \right)$ \\ \hline
        Same & Same & No & $F\left( {n - m,m} \right)$ \\
        \hline
    \end{tabular}
\end{table}


\subsubsection{相同的球 相同的盒子 至少一个}
\lstinputlisting[language={C++}]{source/dp/place_same_balls_into_same_boxes_one.cpp}

\subsubsection{相同的球 相同的盒子 可以为空}
\lstinputlisting[language={C++}]{source/dp/place_same_balls_into_same_boxes_empty.cpp}

\subsubsection{相同的球 不同的盒子 至少一个}
\lstinputlisting[language={C++}]{source/dp/place_same_balls_into_dif_boxes_one.cpp}

\subsubsection{相同的球 不同的盒子 可以为空}
\lstinputlisting[language={C++}]{source/dp/place_same_balls_into_dif_boxes_empty.cpp}

\subsubsection{不同的球 相同的盒子 至少一个}
\lstinputlisting[language={C++}]{source/dp/place_dif_balls_same_boxes_one.cpp}

\subsubsection{不同的球 相同的盒子 可以为空}
\lstinputlisting[language={C++}]{source/dp/place_dif_balls_same_boxes_empty.cpp}

\subsubsection{不同的球 不同的盒子 至少一个}
\lstinputlisting[language={C++}]{source/dp/place_dif_balls_dif_boxes_one.cpp}

\subsubsection{不同的球 不同的盒子 可以为空}
\lstinputlisting[language={C++}]{source/dp/place_dif_balls_dif_boxes_empty.cpp}


\subsection{最大 1 矩阵}
\lstinputlisting[language={C++}]{source/dp/zero_one_matrix.cpp}

\subsection{最大子段和}
\lstinputlisting[language={C++}]{source/dp/maximum_field_sum.cpp}

\subsection{最大 M 子段和}
\lstinputlisting[language={C++}]{source/dp/maximum_m_field_sum.cpp}

\subsection{最长公共递增子序列(记录路径)}
\lstinputlisting[language={C++}]{source/dp/longest_common_increasing_subsequence.cpp}

\subsection{最长公共子序列}
\lstinputlisting[language={C++}]{source/dp/longest_common_subsequence.cpp}

\subsection{RMQ 问题}

\subsubsection{题目描述}
RMQ 问题是求给定区间中的最值问题。\\
当然，最简单的算法是 O(n)的，但是对于查询次数很多（设置多大 100 万次），O(n)的算法效率不够。\\
可以用线段树将算法优化到 O（logn)（在线段树中保存线段的最值）。\\
不过，Sparse\_Table 算法才是最好的：它可以在O(nlogn)的预处理以后实现 O(1)的查询效率。\\
思路分析：\\
下面把 Sparse Table 算法分成预处理和查询两部分来说明(以求最小值为例)。\\


\subsubsection{预处理}
预处理使用 DP 的思想，f(i, j)表示[i, i+$2^j$ - 1]区间中的最小值，我们可以开辟一个数组专门来保存 f(i, j)的值。\\
例如，f(0, 0)表示[0,0]之间的最小值,就是 num[0], f(0,2)表示[0, 3]之间的最小值, f(2, 4)表示[2, 17]之间的最小值\\
注意, 因为 f(i, j)可以由 f(i, j - 1)和 f(i+$2^{j-1}$, j-1)导出,而递推的初值(所有的 f(i, 0) = i)都是已知的\\
所以我们可以采用自底向上的算法递推地给出所有符合条件的 f(i, j)的值。\\


\subsubsection{查询}
假设要查询从 m 到 n 这一段的最小值, 那么我们先求出一个最大的 k, 使得 k 满足 $2^k$ <= (n - m + 1).\\
于是我们就可以把[m, n]分成两个(部分重叠的)长度为 $2^k$ 的区间: [m, m+$2^k$-1], [n-$2^k$+1, n];\\
而我们之前已经求出了 f(m, k)为[m, m+$2^k$-1]的最小值, f(n-$2^k$+1, k)为[n-$2^k$+1, n]的最小值\\
我们只要返回其中更小的那个, 就是我们想要的答案,这个算法的时间复杂度是 O(1)的.\\
例如, rmq(0, 11) = min(f(0, 3), f(4, 3))\\


\subsubsection{样例代码}
\lstinputlisting[language={C++}]{source/dp/rmq.cpp}

\subsection{LCA 问题}
对于该问题，最容易想到的算法是分别从节点 u 和 v回溯到根节点，获取 u 和 v 到根节点的路径P1，P2，其中 P1 和 P2 可以看成两条单链表，这就转换成常见的一道面试题：【判断两个单链表是否相交，如果相交，给出相交的第一个点。】。\\
该算法总的复杂度是 O（n）（其中 n 是树节点个数）。\\
本节介绍了两种比较高效的算法解决这个问题，其中一个是在线算法（DFS+ST），另一个是离线算法（Tarjan 算法）。\\
实际上还有一个最简单的方法，先求出两个点的高度，然后根据高度来向上找到公共祖先。\\
复杂度是两个高度之和。

\subsubsection{在线算法 DFS+ST}
\lstinputlisting[language={C++}]{source/dp/lca_st_online.cpp}

\subsubsection{离线算法（Tarjan 算法）}
\lstinputlisting[language={C++}]{source/dp/taejan_offline.cpp}

\subsection{矩阵相乘 DP}

\subsubsection{求矩阵状态}
\lstinputlisting[language={C++}]{source/dp/matrix_born_state.cpp}

\subsubsection{使用矩阵幂求答案}
\lstinputlisting[language={C++}]{source/dp/matrix_pow_dp.cpp}

\subsection{DFA+DP}

\subsubsection{区间个数询问}
\lstinputlisting[language={C++}]{source/dp/dfa_interval_number.cpp}

\subsection{区间内第 k 个满足条件的}


\subsubsection{二分查找}
\lstinputlisting[language={C++}]{source/dp/interval_kth_binary.cpp}

\subsection{DFA 查找}
\lstinputlisting[language={C++}]{source/dp/interval_kth_dfa.cpp}

\section{搜索}

\subsection{KMP 匹配算法 O(M+N)}
\lstinputlisting[language={C++}]{source/search/kmp.cpp}

\subsection{回文串~Manacher算法}
\lstinputlisting[language={C++}]{source/search/manacher.cpp}


\subsection{迭代加深搜索}
对于一般的搜索，复杂度是 O($2^n$)的复杂度。\\
对于不知道比较好的算法时，只有进行暴力搜索了。\\
但是 DFS 可能进去出不来，对于 BFS 又可能爆栈。这是就要进行迭代搜索了。\\
每当加深一层深度时，次层的搜索的时间可以忽略不计了，因为相差一个数量级。\\


\subsection{IDA*}
\lstinputlisting[language={C++}]{source/search/IDA_star.cpp}


\subsection{棋盘多项式与禁位排列}
一个 n*n 个方格组成的图形去掉其中某些方格，称为是一个棋盘(每行每列至多一个)\\
棋盘方案数 Rk(C):有 C 个格子构成的一个棋盘，放了 k 个棋子。\\
棋盘多项式:R(C)=r0(C)+r1(C)x+r2(C)x2+...+ri(C)xi \\
称为是棋盘 C 的棋盘多项式。（r0(C)=1）\\
在棋盘 C 中任取一个格，将这个格去掉，得到的棋盘记作 C(e) 把这个格所在的行和列的格都去掉得到的棋盘记作 C(x)\\
Rk(C)=Rk-1(C(x))+Rk(C(e))\\
有禁区的排列可以用棋盘和容斥原理解决这类问题。\\


\subsection{容斥原理}
\lstinputlisting[language={C++}]{source/search/inclusion_and_exclusion.cpp}


\subsection{小于 n 的个数字的个数}
\lstinputlisting[language={C++}]{source/search/number_of_less_n.cpp}


\subsection{DFA+DP}
\begin{lstlisting}
`一般用于解决与位有关系的搜索`
\end{lstlisting}

\subsubsection{求区间内满足条件的个数}
\lstinputlisting[language={C++}]{source/search/interval_dfa_number.cpp}

\subsubsection{求区间内第几个满足条件的数}
\lstinputlisting[language={C++}]{source/search/interval_dfa_kth.cpp}

\section{STL}
\subsection{vector}
\lstinputlisting[language={C++}]{source/STL/vector.cpp}

\subsection{优先队列}
\lstinputlisting[language={C++}]{source/STL/priority_queue.cpp}

\subsection{排序}
\lstinputlisting[language={C++}]{source/STL/sort.cpp}

\subsection{qsort()}
\lstinputlisting[language={C++}]{source/STL/qsort.cpp}

\subsection{双向队列 deque}
\lstinputlisting[language={C++}]{source/STL/deque.cpp}

\subsection{队列 queue}
\lstinputlisting[language={C++}]{source/STL/queue.cpp}

\subsection{栈 stack}
\lstinputlisting[language={C++}]{source/STL/stack.cpp}

\subsection{bitset}
\lstinputlisting[language={C++}]{source/STL/bitset.cpp}

\section{博弈}

\subsection{Combinatorial Game}
\lstinputlisting[language={C++}]{source/game/combinatorial.cpp}

\subsection{第一类取石子（巴什博弈）}
\lstinputlisting[language={C++}]{source/game/combinatorial_first.cpp}

\subsection{第二类取石子（威佐夫博弈）}
\lstinputlisting[language={C++}]{source/game/combinatorial_second.cpp}

\subsection{第三类取石子（尼姆博弈）}
\lstinputlisting[language={C++}]{source/game/combinatorial_third.cpp}

\subsection{Sprague-Grundy 函数}
\lstinputlisting[language={C++}]{source/game/sprague_grundy.cpp}

\subsection{Sprague-Grundy 函数性质}
\lstinputlisting[language={C++}]{source/game/sprague_grundy_property.cpp}

\subsection{Sprague-Grundy 函数意义}
\lstinputlisting[language={C++}]{source/game/sprague_grundy_meaning.cpp}

\subsection{SG 定理}
\lstinputlisting[language={C++}]{source/game/sprague_grundy_theorem.cpp}

\subsection{求 SG 值的问题求 SG 算法}
1.直接 DFS\\
2.外加数组法（效率更高）\\

\subsubsection{直接 DFS 算法}
\lstinputlisting[language={C++}]{source/game/sprague_grundy_dfs.cpp}

\subsection{外接数组法}
\lstinputlisting[language={C++}]{source/game/sprague_grundy_array.cpp}

\section{图论}
\begin{lstlisting}
\end{lstlisting}

\subsection{图的一维数组邻接表表示法}
\lstinputlisting[language={C++}]{source/graph/array_Adjacency_list.cpp}

\subsection{Dijkstra}
\lstinputlisting[language={C++}]{source/graph/dijkstra.cpp}

\subsubsection{O($n^2$)算法}
\lstinputlisting[language={C++}]{source/graph/dijkstra_n_2.cpp}

\subsubsection{堆优化 O(n*log(n))算法}
\lstinputlisting[language={C++}]{source/graph/dijkstra_n_log_n.cpp}

\subsection{Bellman-Ford}
\lstinputlisting[language={C++}]{source/graph/bellman_ford.cpp}

\subsection{SPFA}
\lstinputlisting[language={C++}]{source/graph/spfa.cpp}

\subsubsection{栈实现}
\lstinputlisting[language={C++}]{source/graph/spfa_stack.cpp}

\subsubsection{队列实现}
\lstinputlisting[language={C++}]{source/graph/spfa_queue.cpp}

\subsubsection{Vector 储存}
\lstinputlisting[language={C++}]{source/graph/spfa_vector.cpp}

\subsection{最小生成树}
\begin{lstlisting}
\end{lstlisting}

\subsubsection{Kruskal 算法}
\lstinputlisting[language={C++}]{source/graph/mst_kruskal.cpp}

\subsubsection{Prim 算法}
\lstinputlisting[language={C++}]{source/graph/mst_prim.cpp}

\subsection{欧拉图}
欧拉通路 (欧拉迹):通过图中每条边且只通过一次，并且经过每一顶点的通路。\\
欧拉回路 (欧拉闭迹):通过图中每条边且只通过一次，并且经过每一顶点的回路。\\
欧拉图:存在欧拉回路的图。\\
简单说欧拉通路就是首尾不相接，而欧拉回路要求首尾相接。\\

\subsubsection{无向图的判定}
欧拉通路:图连通；图中只有 2 个度为奇数的节点(就是欧拉通路的 2 个端点)\\
欧拉回路:图连通；图中所有节点度均为偶数\\

\subsubsection{有向图的判定}
欧拉通路:图连通；除 2 个端点外其余节点入度=出度；1 个端点入度比出度大 1；一个端点入度比出度小 1\\
欧拉回路:图连通；所有节点入度=出度\\

\subsection{网络流}
\lstinputlisting[language={C++}]{source/graph/network.cpp}

\subsection{给定的度序列构成无向图}
对于一个给定的度序列，看能不能形成一个简单无向图\\
 Havel 算法的思想简单的说如下：\\
 （1）对序列从大到小进行排序。\\
 （2）设最大的度数为 t ，把最大的度数置0，然后把最大度数后（不包括自己）的 t 个度数分别减 1（意思就是把度数最大的点与后几个点进行连接）\\
 （3）如果序列中出现了负数，证明无法构成。如果序列全部变为 0，证明能构成，跳出循环。前两点不出现，就跳回第一步！\\


\subsection{最大团}
\lstinputlisting[language={C++}]{source/graph/maximum_mission.cpp}

\subsection{次小生成树}
\lstinputlisting[language={C++}]{source/graph/small_spanning_tree.cpp}

\subsection{第 K 短路}
\lstinputlisting[language={C++}]{source/graph/kth_shortest.cpp}

\subsection{查分约束}
\lstinputlisting[language={C++}]{source/graph/differential_constraints.cpp}

\subsection{二分匹配}
\begin{lstlisting}
\end{lstlisting}

\subsubsection{Hungary（匈牙利）算法}
\lstinputlisting[language={C++}]{source/graph/hungary.cpp}

\subsubsection{Hopcroft–Karp 算法}
\lstinputlisting[language={C++}]{source/graph/hopcroft_karp.cpp}

\subsubsection{最大权匹配的 KM 算法}
\lstinputlisting[language={C++}]{source/graph/km.cpp}

\subsection{强连通分支算法}
有向图 G=(V, E)的一个强连通分支就是一个最大的顶点子集 C，对于 C 中每对顶点(s, t)，有 s 和 t 是强连通的，并且 t 和 s 也是强连通的，即顶点 s 和 t 是互达的。\\

\subsubsection{Kosaraju 算法}
Kosaraju 算法的解释和实现都比较简单，为了找到强连通分支，首先对图 G 运行 DFS，计算出各顶点完成搜索的时间 f；然后计算图的逆图 GT，对逆图也进行 DFS 搜索，但是这里搜索时顶点的访问次序不是按照顶点标号的大小，而是按照各顶点 f 值由大到小的顺序；逆图 DFS 所得到的森林即对应连通区域\\

\subsubsection{矩阵储存}
\lstinputlisting[language={C++}]{source/graph/kosaraju_matrix.cpp}


\subsubsection{邻接表储存}
\lstinputlisting[language={C++}]{source/graph/kosaraju_adjacency_list.cpp}

\subsection{Tarjan 算法}
\lstinputlisting[language={C++}]{source/graph/tarjan.cpp}

\subsection{树的中心}
\lstinputlisting[language={C++}]{source/graph/center_of_tree.cpp}

\section{JAVA}
\subsection{a+b}
\begin{lstlisting}[language={Java}]
import java.math.BigInteger;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        BigInteger a;
        Scanner cin = new Scanner(System.in);
        while (cin.hasNextBigInteger()) {
            a = cin.nextBigInteger();
            System.out.println(a.toString());
        }
    }
}
\end{lstlisting}

\section{参考资料}
\begin{lstlisting}
`吉大模板`
`NENUCS 模板`
`NENUCS 张某人的模板`
`NENUCS 赵小舟的模板`
`历年来国家集训队论文`
`wiki http://en.wikipedia.org/wiki/Main\_Page§`
\end{lstlisting}





\section{赵小舟的模板}

\subsection{Graph}

\subsubsection{Basic}

\begin{lstlisting}
#define maxn 505
#define maxm 250050
using namespace std;
struct edges {
   int u, c, next;
} e[maxm];
int p[maxn], idx;
int n, m; // |V|, |E|
void addedge(int u, int v, int c) {
    e[idx].u = v;
    e[idx].c = c;
    e[idx].next = p[u];
    p[u] = idx++;
}
void init() {
    idx = 0;
    memset(p, 0xff, sizeof(p));
}
\end{lstlisting}

\subsubsection{Floyd}
\begin{lstlisting}
int n;
int mp[maxn][maxn]; //mp[][] = inf; mp[i][i] = 0;

void floyd(){
    for(int k=0;k<n;k++){
        for(int i=0;i<n;i++){
            if(i == k) continue;
            for(int j=0;j<n;j++){
                if(mp[i][k] + mp[k][j] < mp[i][j]) {
                    mp[i][j] = mp[i][k] + mp[k][j];
                }
            }
        }
    }
}
\end{lstlisting}
\subsubsection{SPFA}
\begin{lstlisting}
int dist[maxn];
bool used[maxn];
queue<int> q;

void spfa(int s){
    int t, u, w;
    while(!q.empty()) q.pop();
    memset(used, false, sizeof(used));
    for(int i=0;i<n;i++) dist[i] = inf;
    dist[s] = 0;
    q.push(s);
    while(!q.empty()){
        t = q.front();
        q.pop();
        used[t] = false;
        for(int i=p[t];i!=-1;i=e[i].next){
            u = e[i].u;
            w = e[i].c;
            if(dist[t] + w < dist[u]){
                dist[u] = dist[t] + w;
                if(!used[u]){
                    used[u] = true;
                    q.push(u);
                }
            }
        }
    }
}
\end{lstlisting}

\subsubsection{Dijkstra}
\begin{lstlisting}
struct node{
    int u, c;
    node (int u, int c) : u(u), c(c) {}
    node () {}
    friend bool operator <(node a, node b){
        return a.c > b.c;
    }
}tmp;
int dist[maxn];
bool used[maxn];
priority_queue<node> q;

void dijkstra(int s, int d){
    int t, u, w;
    while(!q.empty()) q.pop();
    memset(used, false, sizeof(used));
    for(int i=0;i<n;i++) dist[i] = inf;
    tmp = node(s, 0);
    dist[s]=0;
    q.push(tmp);
    while(!q.empty()){
        tmp = q.top();
        q.pop();
        t = tmp.u;
        if(used[t]) continue;
        else used[t] = true;
        if(t == d) return;
        for(int i=p[t];i!=-1;i=e[i].next){
            u = e[i].u;
            w = e[i].c;
            if(used[u]) continue;
            if(dist[t] + w < dist[u]){
                dist[u] = dist[t] + w;
                q.push( node(u, dist[u]) );
            }
        }
    }
}
\end{lstlisting}

\subsubsection{Prim}
\begin{lstlisting}
#define maxn 101
using namespace std;
int mp[maxn][maxn];
bool inTree[maxn];
int min_length[maxn];

int prim(int n){
    int sum = 0;
    memset(inTree,false,sizeof(inTree));
    for(int i=1;i<n;i++) min_length[i] = inf;
    min_length[0] = 0;
    for(int i=0;i<n;i++){
        int min_index = -1;
        for(int j=0;j<n;j++){
          if(!inTree[j] &&
             (min_index == -1 || min_length[j] < min_length[min_index]) ){
             min_index = j;
          }
        }
        inTree[min_index] = true;
        sum += min_length[min_index];
        for(int j=0;j<n;j++){
           if(!inTree[j] && mp[j][min_index] < min_length[j] ){
                 min_length[j] = mp[j][min_index];
           }
        }
    }
    return sum;
}
\end{lstlisting}

\subsubsection{Sap}
\begin{lstlisting}
struct edges{
    int u,c,next;
}e[maxm];
int p[maxn],idx;
int n, m;

void addedge(int u,int v,int c,int cc=0){
    e[idx].u=v; e[idx].c=c;  e[idx].next=p[u]; p[u]=idx++;
    e[idx].u=u; e[idx].c=cc; e[idx].next=p[v]; p[v]=idx++;

}
void init(){ idx=0; memset(p,0xff,sizeof(p));}

int gap[maxn],dis[maxn],pre[maxn],cur[maxn];

int sap(int s,int t){
    memset(dis,0,sizeof(dis));
    memset(gap,0,sizeof(gap));
    for(int i=1;i<=n;i++)cur[i]=p[i];
    int u=pre[s]=s, max_flow=0,step=inf;
    gap[0]=n;
    while(dis[s]<n){
loop:   for(int &i=cur[u];i!=-1;i=e[i].next){
            int v=e[i].u;
            if(e[i].c>0 && dis[u]==dis[v]+1){
                step=min(step,e[i].c);
                pre[v]=u;
                u=v;
                if(v==t){
                    max_flow += step;
                    for(u=pre[u];v!=s;v=u,u=pre[u]){
                        e[cur[u]].c -= step;
                        e[cur[u]^1].c += step;
                    }
                    step=inf;
                }
                goto loop;
            }
        }
        int mindis=n;
        for(int i=p[u];i!=-1;i=e[i].next){
            int v=e[i].u;
            if(e[i].c>0 && mindis>dis[v]){
                cur[u]=i;
                mindis=dis[v];
            }
        }
        if( (--gap[dis[u]])==0) break;
        gap[ dis[u] = mindis+1] ++;
        u=pre[u];
    }
    return max_flow;
}
\end{lstlisting}

\subsubsection{Hungary\_Matrix}
\begin{lstlisting}
int mat[maxn][maxn];
int matx[maxn],maty[maxn];
bool fy[maxn];
int N,M;

int path(int u){
   int v;
   for(v=0;v<M;v++){
      if(mat[u][v] && !fy[v]){
         fy[v]=1;
         if(maty[v]<0 || path(maty[v])){
            matx[u]=v;
            maty[v]=u;
            return 1;
         }
      }
   }
   return 0;
}
int hungary(){
   int res=0;
   memset(matx,0xff,sizeof(matx));
   memset(maty,0xff,sizeof(maty));
   for(int i=0;i<N;i++){
       if(matx[i]<0){
           memset(fy,false,sizeof(fy));
           res+=path(i);
       }
   }
   return res;
}
\end{lstlisting}

\subsubsection{Cut-Vertex}
\begin{lstlisting}
int dfn[maxn], low[maxn], cnt[maxn], cont;
void dfs(int u, int pre) {
    int v;
    dfn[u] = low[u] = ++cont;
    for (int i = p[u]; ~i; i = e[i].next) {
        v = e[i].u;
        if (!dfn[v]) {
            dfs(v, pre);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u]) ++cnt[u];
        }
        else {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (u != pre) ++cnt[u];
}
void init() {
    cont = 0;
    memset(dfn, 0, sizeof dfn);
    memset(cnt, 0, sizeof cnt);
}
// for (int i = 1; i <= n; ++i) if (!dfn[i]) dfs(i, i);
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}


%\clearpage

\subsection{Data Structure and Others}

\subsubsection{LIS}
\begin{lstlisting}
int lis(int p){
    int len=0,low,high,mid;
    //dp[0]=-inf;
    for(int i=0;i<p;i++){
        low=1,high=len;
        while(low<=high){
           mid=(low+high)/2;
           if(a[i]>dp[mid])low=mid+1;
           else high=mid-1;
        }
        dp[low]=a[i];
        if(low>len)len++;
    }
    return len;
}
\end{lstlisting}

\subsubsection{RMQ}
\begin{lstlisting}
//RMQ(max)
int dpm[20][maxn];
void init(int N){
    for(int i=1;i<=N;i++){dpm[0][i]=a[i];}
    for(int j=1;(1<<j)<=N;j++){
        for(int i=1;i+(1<<j)-1<=N;i++){
            dpm[j][i]=max(dpm[j-1][i],dpm[j-1][i+(1<<(j-1))]);
        }
    }
}
int getm(int a,int b){
    int k=(int)(log((double)(b-a+1))/log(2.0));
    return max(dpm[k][a],dpm[k][b-(1<<k)+1]);
}
\end{lstlisting}

\subsubsection{Reversed number}
\begin{lstlisting}
int a[maxn], c[maxn];
__int64 ret;
void MergeSort(int l, int r) {
    if (l < r) {
        int mid = (l + r) >> 1;
        MergeSort(l, mid);
        MergeSort(mid + 1, r);
        int i = l, j = mid + 1, k = l;
        for (; i <= mid && j <= r; ) {
            if (a[i] <= a[j]) {
                c[k++] = a[i++];
            }
            else {
                ret += j - k;
                c[k++] = a[j++];
            }
        }
        while (i <= mid) c[k++] = a[i++];
        while (j <= r) c[k++] = a[j++];
        for (i = l; i <= r; ++i) a[i] = c[i];
    }
}
\end{lstlisting}

\subsubsection{max\_sum(plusplus)}
\begin{lstlisting}

using namespace std;
int a[1000001],b[1000001],num[1000001];
int main(){
    int M,N;
    while(scanf("%d%d",&M,&N)!=EOF && M && N){
        num[0]=0;
        for(int i=1;i<=N;i++)scanf("%d",&num[i]);
        memset(a,0,(N+1)*sizeof(a[0]));
        memset(b,0,(N+1)*sizeof(b[0]));
        int max;
        for(int i=1;i<=M;i++){
           max=0x80000000;
           for(int j=i;j<=N;j++){
               if(a[j-1]<b[j-1])a[j]=b[j-1]+num[j];
               else a[j]=a[j-1]+num[j];
               b[j-1]=max;
               if(a[j]>max)max=a[j];
           }
           b[N]=max;
        }
        printf("%d\n",max);
    }
    return 0;
}
\end{lstlisting}

\iffalse
\subsubsection{Divide $m$ apples to $n$ plates(can be zero)}
\begin{lstlisting}
long long f[maxn][maxn];
long long dp(int n, int m){
    if(m<0 || n<0)return 0;
	if(n > m)	n = m;
	int i, j;
	for(i = 0; i <= m; ++i)
		f[i][1] = 1;
	for(j = 0; j <= n; ++j)
		f[0][j] = 1;
	for(i = 1; i <= m; ++i)
		for(j = 2; j <= n; ++j){
			f[i][j] = f[i][j-1]%c;
			if(i >= j)
				f[i][j] += f[i-j][j]%c;
		}
	return f[m][n]%c;
}
\end{lstlisting}
\fi

\subsubsection{Trie(52)}
\begin{lstlisting}
#define maxn 151
#define WORD_LEN 32
#define MAX_WORD 52
using namespace std;
struct Trie_Node{
    int id;
    Trie_Node *next[MAX_WORD];
    void init(){
         id=-1;
         memset(next,NULL,sizeof(next));
    }
}trie[maxn*WORD_LEN],root;
int tidx,cnt;
int insert(char* s){
    int i,j;
    Trie_Node *p=&root;
    for(i=0;s[i];i++){
        if(s[i]<='Z')j=s[i]-'A';
        else j=s[i]-'a'+26;
        if(p->next[j]==NULL){
            trie[tidx].init();
            p->next[j]=&trie[tidx++];
        }
        p=p->next[j];
    }
    if(p->id==-1)p->id=cnt++;
    return p->id;
}
void init(){
    root.init();
    tidx=cnt=0;
}
\end{lstlisting}

\subsubsection{BinaryIndexedTree}
\begin{lstlisting}
struct binaryIndexedTrees{
    int num[maxn];
    void init(){
        memset(num,0,sizeof(num));
    }
    int lowbit(int x){
        return x&(-x);
    }
    void update(int p,int c){
        while(p<maxn){
            num[p] += c;
            p += lowbit(p);
        }
    }
    int sum(int p){
        int t=0;
        while(p>0){
            t += num[p];
            p -= lowbit(p);
        }
        return t;
    }
    int find_kth(int k){  // if (k > limit), return maxn;  if (k < 0) return 1
        int now=0;
        for(int i=20;i>=0;i--){
            now |= (1<<i);
            if(now>=maxn || num[now]>=k){
                now ^= (1<<i);
            }
            else k -= num[now];
        }
        return now + 1;
    }
    int getkth2(int k){  //kth_2
            int l=0,r=maxn,mid,f;
            while(l<r-1){
                mid=(l+r)>>1;
                f=sum(mid);
                if(f>=k) r=mid;
                else l=mid;
            }
            return r;
    }
}bit;
\end{lstlisting}

\subsubsection{Union\_Set}
\begin{lstlisting}
int parents[maxn];
int Find(int a){
    return parents[a] < 0 ? a : parents[a] = Find(parents[a]);
}
void Union(int a,int b){
    if(parents[a] < parents[b]){ parents[a] += parents[b], parents[b] = a;}
    else{ parents[b] += parents[a], parents[a] = b;}
}
void init(){
    memset(parents, 0xff, sizeof(parents));
}
\end{lstlisting}


\subsubsection{Union\_Set(Vector)}
\begin{lstlisting}
int parents[maxn], v[maxn];
int Find(int a){
    if(parents[a] < 0) return a;
    else{
	int t = parents[a];
        parents[a] = Find(parents[a]);
        v[a] = (v[a] + v[t]) % LEN;
        return parents[a];
    }
}
void Union(int a,int b,int c){
    if(parents[a] < parents[b]){
        parents[a] += parents[b];
        parents[b] = a;
        v[b] = (v[b] + c) % LEN;
    }
    else{
        parents[b] += parents[a];
        parents[a] = b;
        v[a] = (v[a] - c + LEN) % LEN;
    }
}
Union(ra, rb, (v[a] - v[b] + c + LEN) % LEN); //addedge(b, a, c)
\end{lstlisting}


\subsubsection{suffix\_array}
\begin{lstlisting}
#define MAXL 100100
#define MAXC 256
using namespace std;
int arr[3][MAXL], cnt[MAXL], mc[MAXC], h[MAXL], *sa, *ta, *r, *tr, sz;
void sa_init(char *str, int len){
    sa = arr[0], ta = arr[1], r = arr[2], sz = 0;
    for(int i=0;i<len;i++) ta[i] = str[i];
    sort(ta, ta + len);
    for(int i=1;i<=len;i++){
        if(ta[i] != ta[i-1] || i == len) cnt[ mc[ ta[i-1] ] = sz++ ] = i;
    }
    for(int i=len-1;i>=0;i--) sa[ --cnt[ r[i] = mc[ str[i] ]]] = i;
    for(int k=1;k<len && r[sa[len-1]]<len-1;k<<=1){
        for(int i=0;i<len;i++) cnt[r[sa[i]]] = i + 1;
        for(int i=len-1;i>=0;i--) {
            if(sa[i] >= k) ta[ --cnt[ r[sa[i] - k] ] ] = sa[i] - k;
        }
        for(int i=len-k;i<len;i++) ta[ --cnt[r[i]] ] = i;
        tr = sa, sa = ta, tr[sa[0]] = 0;
        for(int i=1;i<len;i++) {
            tr[sa[i]] = tr[sa[i-1]] +
                (r[sa[i]] != r[sa[i-1]] || sa[i-1]+k >= len
                    || r[sa[i]+k] != r[sa[i-1]+k]);
        }
        ta = r, r = tr;
    }
}
void h_init(char *str, int len){
    for(int i=0,d=0,j;i<len;i++){
        if(str[i] == '#' || r[i] == len-1) h[r[i]] = d = 0; //'#' = 35
        else{
            if(d) d--;
            j = sa[r[i] + 1];
            while(str[i+d] != '#' && str[j+d] != '#'
                  && str[i+d] == str[j+d])
                    d++;
            h[r[i]] = d;
        }
    }
}
char str[MAXL];
\end{lstlisting}

\subsubsection{sa\_methods}
\begin{lstlisting}
Distinct Substrings = len * (len - 1) / 2 - sigma(i = 0..len - 1)(h[i])
\end{lstlisting}
\subsubsection{RMQ(pos)}
\begin{lstlisting}
int a[maxn];
int lg[maxn], dpmax[20][maxn], dpmin[20][maxn];
int maxpos[20][maxn], minpos[20][maxn];
void rmq_init(int n){
    int i, j, k;
    for(lg[0]=-1,i=1;i<=n;i++){
        lg[i] = ((i & (i - 1)) == 0)? lg[i - 1] + 1: lg[i - 1];
        dpmax[0][i] = dpmin[0][i] = a[i];
        maxpos[0][i] = minpos[0][i] = i;
    }
    for(k=1;k<=lg[n];k++){
        for(i=1;i+(1<<k)-1<=n;i++){
            j = i + (1 << (k - 1));
            if(dpmax[k - 1][i] > dpmax[k - 1][j]){
                dpmax[k][i] = dpmax[k - 1][i];
                maxpos[k][i] = maxpos[k - 1][i];
            }
            else{
                dpmax[k][i] = dpmax[k - 1][j];
                maxpos[k][i] = maxpos[k - 1][j];
            }
            if(dpmin[k - 1][i] < dpmin[k - 1][j]){
                dpmin[k][i] = dpmin[k - 1][i];
                minpos[k][i] = minpos[k - 1][i];
            }
            else{
                dpmin[k][i] = dpmin[k - 1][j];
                minpos[k][i] = minpos[k - 1][j];
            }
        }
    }
}
int getMax(int a, int b){
    int t = lg[b - a + 1], p = b - (1 << t) + 1;
    return max(dpmax[t][a], dpmax[t][p]);
}
int getMin(int a, int b){
    int t = lg[b - a + 1], p = b - (1 << t) + 1;
    return min(dpmin[t][a], dpmin[t][p]);
}
int getMaxpos(int a, int b){
    int t = lg[b - a + 1], p = b - (1 << t) + 1;
    if(dpmax[t][a] > dpmax[t][p]) return maxpos[t][a];
    else return maxpos[t][p];
}
int getMinpos(int a, int b){
    int t = lg[b - a + 1], p = b - (1 << t) + 1;
    if(dpmin[t][a] < dpmin[t][p]) return minpos[t][a];
    else return minpos[t][p];
}
\end{lstlisting}

\subsubsection{lcp}
\begin{lstlisting}
int RMQ[MAXL];
int mm[MAXL];
int best[20][MAXL];
void initRMQ(int n)
{
     int i,j,a,b;
     for(int i=1;i<=n;i++)RMQ[i] = h[i-1];
     for(mm[0]=-1,i=1;i<=n;i++)
     mm[i]=((i&(i-1))==0)?mm[i-1]+1:mm[i-1];
     for(i=1;i<=n;i++) best[0][i]=i;
     for(i=1;i<=mm[n];i++)
     for(j=1;j<=n+1-(1<<i);j++)
     {
       a=best[i-1][j];
       b=best[i-1][j+(1<<(i-1))];
       if(RMQ[a]<RMQ[b]) best[i][j]=a;
       else best[i][j]=b;
     }
     return;
}
int askRMQ(int a,int b){
    int t;
    t=mm[b-a+1];b-=(1<<t)-1;
    a=best[t][a];b=best[t][b];
    return RMQ[a]<RMQ[b]?a:b;
}
int lcp(int a,int b)
{
    //if(a == b) return len - a;
    int t;
    a=r[a];b=r[b];
    if(a>b) {t=a;a=b;b=t;}
    return(h[askRMQ(a+1,b) - 1]);
}
\end{lstlisting}

\subsubsection{KMP}
\begin{lstlisting}
int const maxn = 100100;
char s[maxn], p[maxn];
int fail[maxn], len;
void buildF(char *p) {
    for (int i = 1, j = fail[0] = ~0; i < len; fail[i++] = j += p[j + 1] == p[i])
        while (~j && p[j + 1] != p[i]) j = fail[j];
}
int kmp(char *s, char *p) {
    int ret = 0;
    for (int i = 0, j = -1; s[i]; ++i) {
        while (~j && p[j + 1] != s[i]) j = fail[j];
        if (p[j + 1] == s[i]) ++j;
        if (j == len - 1) {
            ++ret;
            j = fail[j];
        }
    }
    return ret;
}
\end{lstlisting}

\subsubsection{extKMP}
\begin{lstlisting}
int ext[maxn]; // lcp(pat's suffix, pat)
int ex[maxn]; // lcp(pat's suffix, str)
//exp. str = "aaaba", pat = "aba", then ex[] = {1, 1, 3, 0, 1}, ext[] = {3, 0, 1}
//la = strlen(str), lb = strlen(pat);
void extkmp(char *str, char *pat, int ext[], int ex[]) {
    int p=0,k=1;
    while(pat[p] == pat[p+1]) p++;
    ext[0] = lb, ext[1] = p;
    for(int i=2;i<lb;i++){
        int x = k + ext[k] - i, y = ext[i - k];
        if (y < x) ext[i] = y;
        else{
            p = max(0, x);
            while (pat[p] == pat[p+i]) p++;
            ext[i] = p;
            k = i;
        }
    }
    p = k = 0;
    while(str[p] && str[p] == pat[p]) p++;
    ex[0] = p;
    for(int i=1;i<la;i++){
        int x = k + ex[k] - i, y = ext[i - k];
        if (y < x) ex[i] = y;
        else{
            p = max(0, x);
            while (pat[p] && pat[p] == str[p+i]) p++;
            ex[i] = p;
            k = i;
        }
    }
}
\end{lstlisting}

\subsubsection{Manacher}
\begin{lstlisting}
// "aaa" -> "!#a#a#a#"
int p[MAXL], len;
char str[MAXL];
int pk(){
    int id, mx = 0, res = 0;
    for(int i=0;i<len;i++){
        if(mx > i) p[i] = min(p[2*id-i], mx-i);
        else p[i] = 1;
        for(;str[i+p[i]]==str[i-p[i]];p[i]++);
        res = max(res, p[i]);
        if(p[i] + i > mx){
            mx = p[i] + i;
            id = i;
        }
    }
    return res - 1;
}
\end{lstlisting}

\subsubsection{Lower Representation}
\begin{lstlisting}
char str[MAXL];
int fun(){
    int n = strlen(str);
    int i = 0, j = 1, len = 0, x, y;
    while(i < n && j < n && len < n){
        x = i + len; if(x >= n) x -= n;
        y = j + len; if(y >= n) y -= n;
        if(str[x] == str[y]) len++;
        else if(str[x] < str[y]){
            j += len + 1;
            len = 0;
        }
        else{
            i = j;
            j++;
            len = 0;
        }
    }
    return i;
}
\end{lstlisting}

\subsubsection{lisan}
\begin{lstlisting}
int arr[maxn], rk[maxn], mp[maxn];
int n, mx;
bool cmp(int a, int b){
    return arr[a] < arr[b];
}
void lisan(){
    for(int i=1;i<=n;i++) rk[i] = i;
    sort(rk + 1, rk + n + 1, cmp);
    mp[1] = arr[rk[1]];
    arr[rk[1]] = mx = 1;
    for(int i=2;i<=n;i++){
        if(arr[rk[i]] == mp[mx]) arr[rk[i]] = mx;
        else mp[++mx] = arr[rk[i]], arr[rk[i]] = mx;
    }
}
\end{lstlisting}

\subsubsection{Aho-corasick (trie graph)}
\begin{lstlisting}
int root, idx;
struct trie_node{
    int next[size];
    int fail;
    bool flag;
    void init(){
        fail = -1, flag = false;
        memset(next, 0, sizeof(next));
    }
}trie[maxn * leng];
int q[maxn * leng];
void trie_init(){
    root = idx = 0;
    trie[root].init();
}
void insert(char *s){
    int i, j, p = root;
    for(i=0;s[i];i++){
        j = s[i] - 'A';
        if(!trie[p].next[j]){
            trie[++idx].init();
            trie[p].next[j] = idx;
        }
        p = trie[p].next[j];
    }
    trie[p].flag = true;
}
void build(){
    int j, p;
    q[0] = root;
    for(int l=0,h=1;l<h;){
        p = q[l++];
        for(j=0;j<size;j++){
            if(trie[p].next[j]){
                q[h++] = trie[p].next[j];
                if(trie[p].fail == -1)
                    trie[trie[p].next[j]].fail = root;
                else{
                    trie[trie[p].next[j]].fail =
                        trie[trie[p].fail].next[j];

                    trie[trie[p].next[j]].flag |=
                        trie[trie[trie[p].fail].next[j]].flag;
                }
            }
            else{
                if(trie[p].fail != -1)
                    trie[p].next[j] = trie[trie[p].fail].next[j];
            }
        }
    }
}
\end{lstlisting}
\begin{lstlisting}
\end{lstlisting}
\begin{lstlisting}
\end{lstlisting}

\subsubsection{Matrixs}
\begin{lstlisting}
typedef long long ll;
ll const P = 1000000007LL;
int const maxn = 105;
struct matrix{
    int N;
    ll mat[maxn][maxn];
    void init(){
        scanf("%d", &N);
        for(int i=0;i<N;i++){
            for(int j=0;j<N;j++){
                scanf("%I64d", &mat[i][j]);
            }
        }
    }
    matrix operator+(matrix B){
        matrix C;
        C.N=N;
        for(int i=0;i<N;i++){
            for(int j=0;j<B.N;j++){
                C.mat[i][j]=(mat[i][j]+B.mat[i][j])%P;
            }
        }
        return C;
    }
    matrix operator *(matrix B){
        matrix C;
        C.N=N;
        memset(C.mat,0,sizeof(C.mat));
        for(int i=0;i<N;i++){
            for(int j=0;j<N;j++){
                if(mat[i][j]){
                   for(int k=0;k<N;k++){
                       C.mat[i][k]=(C.mat[i][k]+mat[i][j]*B.mat[j][k])%P;
                   }
                }
            }
        }
        return C;
    }
    matrix operator ^(int n){
        matrix C;
        C.N=N;
        memset(C.mat,0,sizeof(C.mat));
        for(int i=0;i<N;i++)C.mat[i][i]=1;
        while(n){
            if(n&1)C=C*(*this);
            *this=(*this)*(*this);
            n>>=1;
        }
        return C;
    }
    void print(){
        for(int i=0;i<N;i++){
            for(int j=0;j<N;j++){
                if(j == N - 1) cout<<mat[i][j]<<endl;
                else cout<<mat[i][j]<<" ";
            }
        }
    }
}A,B,C;
\end{lstlisting}


\subsubsection{to sum\_Matrix}
\begin{lstlisting}
matrix convert(matrix A){ //
    matrix C;
    C.N=A.N*2;
    memset(C.mat,0,sizeof(C.mat));
    for(int i=0;i<A.N;i++){
        for(int j=0;j<A.N;j++){
            C.mat[i][j]=A.mat[i][j];
        }
    }
    for(int i=0;i<A.N;i++){
        C.mat[i][A.N+i]=1;
        C.mat[A.N+i][A.N+i]=1;
    }
    return C;
}
\end{lstlisting}

\subsubsection{Recycling\_Matrix}
\begin{lstlisting}
struct matrix{
    int n;
    ll mat[maxn];
    void init(){
        for(int i=0;i<n;i++) scanf("%I64d", &mat[i]);
    }
    matrix operator*(matrix B){
        matrix C;
        C.n = n;
        for(int i=0;i<n;i++){
            C.mat[i] = 0;
            for(int j=0;j<n;j++){
                if(i - j >= 0) C.mat[i] += mat[j] * B.mat[i - j];
                else C.mat[i] += mat[j] * B.mat[i - j + n];
            }
            C.mat[i] %= mod;
        }
        return C;
    }
    matrix operator^(int m){
        matrix C;
        C.n = n;
        memset(C.mat, 0, sizeof(C.mat));
        C.mat[0] = 1;
        while(m){
            if(m & 1) C = C * (*this);
            *this = (*this) * (*this);
            m >>= 1;
        }
        return C;
    }
    void print(){
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                cout<<mat[(i - j + n) % n]<<" ";
            }
            cout<<endl;
        }
    }
}A, B, C;

\end{lstlisting}

\subsubsection{$solve\left( {k,n} \right) = 1^k  + 2^{^k }  + ...n^k$}
\begin{lstlisting}
typedef long long ll;
ll const P = 1000000007LL;
int const maxn = 105;
struct matrix {
    //...
    void init(int k) {
        memset(mat, 0, sizeof mat);
        N = k + 2;
        for (int i = 0; i < k + 1; ++i) {
            mat[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                mat[i][j] = mat[i - 1][j - 1] + mat[i - 1][j];
            }
        }
        for (int j = 0; j < k + 1; ++j) {
            mat[k + 1][j] = mat[k][j];
        }
        mat[k + 1][k + 1] = 1;
    }
    //...
}A, B, C;

ll solve(int k, int n) {
    if (n == 0) return 0;
    A.init(k);
    B.N = k + 2;
    memset(B.mat, 0, sizeof B.mat);
    for (int i = 0; i < B.N; ++i) B.mat[i][0] = 1;
    A = (A ^ (n - 1)) * B;
    return A.mat[k + 1][0];
}
\end{lstlisting}


\subsubsection{HashMap}
\begin{lstlisting}
int const maxh = 1000000;
struct HashMap{
    int p[maxh], v[maxh], next[maxh], idx;
    ll dp[maxh];
    void init(){
        idx = 0;
        memset(p, 0xff, sizeof p);
    }
    void add(int u, ll val){
        int x = u % maxh;
        for(int i=p[x];i!=-1;i=next[i]){
            if(v[i] == u){
                dp[i] += val;
                return;
            }
        }
        dp[idx] = val;
        v[idx] = u;
        next[idx] = p[x];
        p[x] = idx++;
    }
} hm[2], *src, *des;
\end{lstlisting}



\subsubsection{SegTree (add, renew, max, min) }
\begin{lstlisting}
#define inf 0x3f3f3f3f
#define Inf 0x3FFFFFFFFFFFFFFFLL
#define maxn 100100
using namespace std;
typedef long long ll;

int n, m;
int arr[maxn];
struct node {
    ll a;
    ll mx, mi;
    ll s, s2;
    int delta;
    void init(int flag, int d, ll x) {
        if (flag == 1) {
            delta = 1;
            a = x;
            s = x * d;
            s2 = x * x * d;
            mx = mi = x;
        }
        else if (flag == 2) {
            delta = 2;
            a += x;
            s2 += 2LL * x * s + x * x * d;
            s += x * d;
            mx += x, mi += x;
        }
    }
} tree[maxn << 2];

inline void pushUp(int p, int lp, int rp) {
    tree[p].s = tree[lp].s + tree[rp].s;
    tree[p].s2 = tree[lp].s2 + tree[rp].s2;
    tree[p].mx = max(tree[lp].mx, tree[rp].mx);
    tree[p].mi = min(tree[lp].mi, tree[rp].mi);
}
inline void pushDown(int p, int lp, int rp, int l, int r, int mid) {
//    printf("pd(%d,%d,%d,%d,%d,%d)\n",p,lp,rp,l,r,mid);
    if (tree[p].delta != 0) {
        if (tree[p].delta == 1) {
            tree[lp].init(1, mid - l + 1, tree[p].a);
            tree[rp].init(1, r - mid, tree[p].a);
            tree[p].delta = 0;
            tree[p].a = 0;
        }
        else {
            if (tree[lp].delta == 1) {
                tree[lp].init(1, mid - l + 1, tree[lp].a + tree[p].a);
            }
            else tree[lp].init(2, mid - l + 1, tree[p].a);
            if (tree[rp].delta == 1) {
                tree[rp].init(1, r - mid, tree[rp].a + tree[p].a);
            }
            else tree[rp].init(2, r - mid, tree[p].a);
            tree[p].delta = 0;
            tree[p].a = 0;
        }
    }

}
void build(int l, int r, int p) {
    if (l == r) {
        tree[p].s = tree[p].mx = tree[p].mi = arr[l];
        tree[p].s2 = arr[l] * arr[l];
        tree[p].delta = 0;
        tree[p].a = 0;
        return;
    }
    int mid = (l + r) >> 1, lp = p << 1, rp = p << 1 | 1;
    build(l, mid, lp);
    build(mid + 1, r, rp);

    pushUp(p, lp, rp);
    tree[p].delta = 0;
    tree[p].a = 0;
}

void update_renew(int l, int r, int a, int b, ll c, int p) {
    if (l == a && r == b) {
        tree[p].init(1, r - l + 1, c);
        return;
    }
    int mid = (l + r) >> 1, lp = p << 1, rp = p << 1 | 1;
    pushDown(p, lp, rp, l, r, mid);
    if (b <= mid) update_renew(l, mid, a, b, c, lp);
    else if (a > mid) update_renew(mid + 1, r, a, b, c, rp);
    else {
        update_renew(l, mid, a, mid, c, lp);
        update_renew(mid + 1, r, mid + 1, b, c, rp);
    }
    pushUp(p, lp, rp);
}

void update_add(int l, int r, int a, int b, ll c, int p) {
    if (l == a && r == b) {
        if (tree[p].delta == 1) {
            tree[p].init(1, r - l + 1, c + tree[p].a);
        }
        else tree[p].init(2, r - l + 1, c);
        return;
    }
    int mid = (l + r) >> 1, lp = p << 1, rp = p << 1 | 1;
    pushDown(p, lp, rp, l, r, mid);
    if (b <= mid) update_add(l, mid, a, b, c, lp);
    else if (a > mid) update_add(mid + 1, r, a, b, c, rp);
    else {
        update_add(l, mid, a, mid, c, lp);
        update_add(mid + 1, r, mid + 1, b, c, rp);
    }
    pushUp(p, lp, rp);
}

ll query_s(int l, int r, int a, int b, int p) {
    if (l == a && r == b) {
        return tree[p].s;
    }
    int mid = (l + r) >> 1, lp = p << 1, rp = p << 1 | 1;
    pushDown(p, lp, rp, l, r, mid);
    if (b <= mid) return query_s(l, mid, a, b, lp);
    else if (a > mid) return query_s(mid + 1, r, a, b, rp);
    else return query_s(l, mid, a, mid, lp) + query_s(mid + 1, r, mid + 1, b, rp);
}
ll query_s2(int l, int r, int a, int b, int p) {
    if (l == a && r == b) {
        return tree[p].s2;
    }
    int mid = (l + r) >> 1, lp = p << 1, rp = p << 1 | 1;
    pushDown(p, lp, rp, l, r, mid);
    if (b <= mid) return query_s2(l, mid, a, b, lp);
    else if (a > mid) return query_s2(mid + 1, r, a, b, rp);
    else return query_s2(l, mid, a, mid, lp) + query_s2(mid + 1, r, mid + 1, b, rp);
}
ll query_mx(int l, int r, int a, int b, int p) {
    if (l == a && r == b) {
        return tree[p].mx;
    }
    int mid = (l + r) >> 1, lp = p << 1, rp = p << 1 | 1;
    pushDown(p, lp, rp, l, r, mid);
    if (b <= mid) return query_mx(l, mid, a, b, lp);
    else if (a > mid) return query_mx(mid + 1, r, a, b, rp);
    else return max( query_mx(l, mid, a, mid, lp), query_mx(mid + 1, r, mid + 1, b, rp) );
}
ll query_mi(int l, int r, int a, int b, int p) {
    if (l == a && r == b) {
        return tree[p].mi;
    }
    int mid = (l + r) >> 1, lp = p << 1, rp = p << 1 | 1;
    pushDown(p, lp, rp, l, r, mid);
    if (b <= mid) return query_mi(l, mid, a, b, lp);
    else if (a > mid) return query_mi(mid + 1, r, a, b, rp);
    else return min( query_mi(l, mid, a, mid, lp), query_mi(mid + 1, r, mid + 1, b, rp) );
}

\end{lstlisting}


\subsubsection{Split tree}
\begin{lstlisting}
#define inf 0x3f3f3f3f
#define Inf 0x3FFFFFFFFFFFFFFFLL
#define maxn 100100
using namespace std;
int num[20][maxn];
int leftcnt[20][maxn];
int sd[maxn];
void build(int l, int r, int d){
    if(l == r) return;
    int mid = (l + r) >> 1;
    int lsame = mid - l + 1;
    for(int i=l;i<=r;i++)if(num[d][i] < sd[mid]) lsame--;
    int lp = l, rp = mid + 1;
    for(int i=l;i<=r;i++){
        if(i == l) leftcnt[d][i] = 0;
        else leftcnt[d][i] = leftcnt[d][i - 1];
        if(num[d][i] < sd[mid]){
            num[d + 1][lp++] = num[d][i];
            leftcnt[d][i]++;
        }
        else if(num[d][i] > sd[mid]){
            num[d + 1][rp++] = num[d][i];
        }
        else{
            if(lsame){
                lsame--;
                num[d + 1][lp++] = num[d][i];
                leftcnt[d][i]++;
            }
            else{
                num[d + 1][rp++] = num[d][i];
            }
        }
    }
    build(l, mid, d + 1);
    build(mid + 1, r, d + 1);
}
int query(int l, int r, int a, int b, int k, int d){
    if(l == r) return num[d][l];
    int mid = (l + r) >> 1;
    int ct = leftcnt[d][b], lct = 0;
    if(l < a){
        ct -= leftcnt[d][a - 1];
        lct = leftcnt[d][a - 1];
    }
    if(ct >= k){
        return query(l, mid, l + lct, l + lct + ct - 1, k, d + 1);
    }
    else{
        k -= ct;
        ct = b - a + 1 - ct;
        lct = a - l - lct;
        return query(mid + 1, r, mid + 1 + lct, mid + lct + ct, k, d + 1);
    }
}
int main(){
    int n, m;
    int a, b, k;
    while(~scanf("%d%d", &n, &m)){
        for(int i=1;i<=n;i++){
            scanf("%d", &num[0][i]);
        }
        memcpy(sd, num[0], sizeof(num[0]));
        sort(sd + 1, sd + n + 1);
        build(1, n, 0);
        while(m--){
            scanf("%d%d%d", &a, &b, &k);
            printf("%d\n", query(1, n, a, b, k, 0));
        }
    }
    return 0;
}
\end{lstlisting}

\subsubsection{Splay}
\begin{lstlisting}
#define maxn 200200
using namespace std;
struct node{
    int key, minv, size, delta, rev;
    node *ch[2], *pre;
    void add(int v){
        if(size == 0) return;
        key += v;
        minv += v;
        delta += v;
    }
    void reverse(){
        if(size == 0) return;
        rev ^= 1;
        swap(ch[0], ch[1]);
    }
    void update(){
        size = ch[0]->size + ch[1]->size + 1;
        minv = min(key, min(ch[0]->minv, ch[1]->minv));
    }
    void pushdown(){
        if(delta){
            ch[0]->add(delta);
            ch[1]->add(delta);
            delta = 0;
        }
        if(rev){
            ch[0]->reverse();
            ch[1]->reverse();
            rev = 0;
        }
    }
};
int num[maxn];
#define keytree root->ch[1]->ch[0]
struct SplayTree{
    int cnt, top;
    node *st[maxn], data[maxn], *root, *null;
    node* newnode(int v){
        node *p;
        if(top) p = st[top--];
        else p = &data[cnt++];
        p->key = p->minv = v;
        p->delta = p->rev = 0;
        p->size = 1;
        p->pre = p->ch[0] = p->ch[1] = null;
        return p;
    }
    void init(){
        cnt = top = 0;
        null = newnode(inf);
        null->size = 0;
        root = newnode(inf);
        root->ch[1] = newnode(inf);
        root->ch[1]->pre = root;
        root->update();
    }
    node* build(int l, int r){
        if(l > r) return null;
        int mid = (l + r) >> 1;
        node *p = newnode(num[mid]);
        p->ch[0] = build(l, mid - 1);
        p->ch[1] = build(mid + 1, r);
        if(p->ch[0] != null) p->ch[0]->pre = p;
        if(p->ch[1] != null) p->ch[1]->pre = p;
        p->update();
        return p;
    }
    // c=0 zag, c=1 zig
    void rotate(node *x, int c){
        node *y = x->pre;
        y->pushdown();
        x->pushdown();
        y->ch[!c] = x->ch[c];
        if(x->ch[c] != null) x->ch[c]->pre = y;
        x->pre = y->pre;
        if(y->pre != null) y->pre->ch[y == y->pre->ch[1]] = x;
        x->ch[c] = y;
        y->pre = x;
        y->update();
        if(y == root) root = x;
    }
    void splay(node *x, node *f){
        x->pushdown();
        while(x->pre != f){
            if(x->pre->pre == f){
                rotate(x, x->pre->ch[0] == x);
                break;
            }
            node *y = x->pre;
            node *z = y->pre;
            int c = (y == z->ch[0]);
            if(y->ch[c] == x){
                rotate(x, !c), rotate(x, c);
            }
            else{
                rotate(y, c), rotate(x, c);
            }
        }
        x->update();
    }
    void select(int k, node *x){
        node *p = root;
        int tmp;
        while(1){
            p->pushdown();
            tmp = p->ch[0]->size;
            if(tmp == k) break;
            else if(tmp < k){
                k -= tmp + 1;
                p = p->ch[1];
            }
            else p = p->ch[0];
        }
        splay(p, x);
    }
/*-----------------------------------------------
ADD x y D: Add D to each number in sub-sequence {Ax ... Ay}.
For example, performing "ADD 2 4 1" on {1, 2, 3, 4, 5} results in {1, 3, 4, 5, 5}
REVERSE x y: reverse the sub-sequence {Ax ... Ay}.
For example, performing "REVERSE 2 4" on {1, 2, 3, 4, 5} results in {1, 4, 3, 2, 5}
REVOLVE x y T: rotate sub-sequence {Ax ... Ay} T times.
For example, performing "REVOLVE 2 4 2" on {1, 2, 3, 4, 5} results in {1, 3, 4, 2, 5}
INSERT x P: insert P after Ax.
For example, performing "INSERT 2 4" on {1, 2, 3, 4, 5} results in {1, 2, 4, 3, 4, 5}
DELETE x: delete Ax.
For example, performing "DELETE 2" on {1, 2, 3, 4, 5} results in {1, 3, 4, 5}
MIN x y: query the minimum number in subsequence{Ax .. Ay}.
For example, the correct answer to "MIN 2 4" on {1, 2, 3, 4, 5} is 2
------------------------------------------------*/
    void add(int a, int b, int c){
        select(a - 1, null);
        select(b + 1, root);
        keytree->add(c);
        splay(keytree, null);
    }
    void reverse(int a, int b){
        select(a - 1, null);
        select(b + 1, root);
        keytree->reverse();
        splay(keytree, null);
    }
    void revolve(int a, int c, int d){
        int len = c - a + 1;
        d %= len; if(d < 0) d += len;
        int b = c - d;
        if(d == 0) return;
        else if(d == 1){
            del(c);
            insert(a - 1, st[top]->key);
        }
        else{
            select(b + 1, null);
            select(c + 1, root);
            select(a - 1, root);
            select(c, root->ch[1]);
            node *p = root->ch[0]->ch[1];
            root->ch[0]->ch[1] = null;
            root->ch[0]->update();
            keytree->ch[1] = p;
            p->pre = keytree;
            splay(p, null);
        }
    }
    void insert(int a, int c){
        select(a, null);
        select(a + 1, root);
        keytree = newnode(c);
        keytree->pre = root->ch[1];
        root->ch[1]->update();
        splay(keytree, null);
    }
    void del(int a){
        select(a, null);
        node *tr = root;
        root = root->ch[1];
        root->pre = null;
        select(0, null);
        root->ch[0] = tr->ch[0];
        root->ch[0]->pre = root;
        root->update();
        st[++top] = tr;
    }
    int getmin(int a, int b){
        select(a - 1, null);
        select(b + 1, root);
        int res = keytree->minv;
        splay(keytree, null);
        return res;
    }
    void debug() {vis(root);}
    void vis(node* t) {
        if (t == null) return;
        t -> pushdown();
        vis(t->ch[0]);
        printf("node%2d:lson %2d,rson %2d,pre %2d,sz=%2d,key=%2d\n",
                t - data, t->ch[0] - data, t->ch[1] - data,
                t->pre - data, t->size, t->key);
        vis(t->ch[1]);
    }
}spt;
int main(){
    int n;
    char op[20]; int x,y,z;
    while(~scanf("%d", &n)){
        for(int i=1;i<=n;i++) scanf("%d", &num[i]);
        spt.init();
        if(n > 0){
            node *tr = spt.build(1, n);
            spt.keytree = tr;
            tr->pre = spt.root->ch[1];
            spt.splay(tr, spt.null);
        }
        //spt.debug();
        ...
    }
    return 0;
}
\end{lstlisting}

\subsubsection{Rectangles' Union Area}
\begin{lstlisting}
#define maxn 1010
using namespace std;
typedef long long ll;
int n;
struct node {
    ll _x1, _x2, y1, y2;
    int x1, x2;
} rec[maxn];

ll xpos[maxn];

int find1(int l, int r, ll x){ // a[res] <= x
    int mid;
    while(l <= r){
        mid = (l + r) >> 1;
        if(xpos[mid] <= x) l = mid + 1;
        else r = mid - 1;
    }
    return r;
}

struct lines{
    int l, r, flag;
    ll h;
    friend bool operator<(lines a, lines b){
        if(a.h == b.h) return a.flag < b.flag;
        else return a.h < b.h;
    }
}line[maxn];

struct tree_node{
    int cnt;
    ll s;
}tree[maxn * 4];

void build(int l, int r, int p){
    if(l == r){
        tree[p].cnt = 0;
        tree[p].s = 0;
        return;
    }
    int mid = (l + r) >> 1;
    build(l, mid, 2*p);
    build(mid+1, r, 2*p+1);
    tree[p].cnt = 0;
    tree[p].s = 0;
}
void node_update(int l, int r, int p, int lp, int rp){
    if(tree[p].cnt >= 1) tree[p].s = xpos[r] - xpos[l - 1];
    else if(l == r) tree[p].s = 0;
    else tree[p].s = tree[lp].s + tree[rp].s;
}
void update(int l, int r, int a, int b, int c, int p){
    int mid = (l + r) >> 1, lp = 2*p, rp = 2*p+1;
    if(l == a && r == b){
        tree[p].cnt += c;
        node_update(l, r, p, lp, rp);
        return;
    }
    if(b <= mid) update(l, mid, a, b, c, lp);
    else if(a > mid) update(mid+1, r, a, b, c, rp);
    else{
        update(l, mid, a, mid, c, lp);
        update(mid+1, r, mid+1, b, c, rp);
    }
    node_update(l, r, p, lp, rp);
}

int main() {
    int _ca = 1;
    while (scanf("%d", &n) && n) {
        int xnt = 0;
        for (int i = 0; i < n; ++i) {
            scanf(" %lld %lld %lld %lld", &rec[i]._x1, &rec[i].y1, &rec[i]._x2, &rec[i].y2);
            xpos[xnt++] = rec[i]._x1, xpos[xnt++] = rec[i]._x2;
        }
        sort(xpos, xpos + xnt);
        int cnt = 1;
        for (int i = 1; i < xnt; ++i) {
            if (xpos[i] != xpos[i - 1]) {
                xpos[cnt++] = xpos[i];
            }
        }
        for (int i = 0; i < n; ++i) {
            rec[i].x1 = find1(0, cnt - 1, rec[i]._x1) + 1;
            rec[i].x2 = find1(0, cnt - 1, rec[i]._x2) + 1;
        }
        int x1, x2; ll y1, y2;
        int N = n << 1;
        for (int i = 0; i < N; i += 2) {
            x1 = rec[i >> 1].x1;
            x2 = rec[i >> 1].x2;
            y1 = rec[i >> 1].y1;
            y2 = rec[i >> 1].y2;
            line[i].l = x1, line[i].r = x2, line[i].h = y1, line[i].flag = 1;
            line[i+1].l = x1, line[i+1].r = x2, line[i+1].h = y2, line[i+1].flag = -1;
        }
        sort(line, line + N);
        build(1, cnt, 1);
        int a, b, c;
        ll ret = 0;
        for (int i = 0;i < N - 1; ++i) {
            a = line[i].l;
            b = line[i].r - 1;
            c = line[i].flag;
            update(1, cnt, a, b, c, 1);
            ret += tree[1].s * (line[i + 1].h - line[i].h);
        }
        printf("Test case #%d\nTotal explored area: %lld\n\n", _ca++, ret);

    }
    return 0;
}
\end{lstlisting}

\subsubsection{Binary\_searches}
\begin{lstlisting}
int find1(int l, int r, int x) { // a[res] <= x
    int mid;
    while (l <= r) {
        mid = (l + r) >> 1;
        if (a[mid] <= x) l = mid + 1;
        else r = mid - 1;
    }
    return r;
}
int find2(int l, int r, int x) { // a[res] < x
    int mid;
    while (l <= r) {
        mid = (l + r) >> 1;
        if (a[mid] < x) l = mid + 1;
        else r = mid - 1;
    }
    return r;
}
int find3(int l, int r, int x) { // a[res] >= x
    int mid;
    while (l <= r) {
        mid = (l + r) >> 1;
        if (a[mid] >= x) r = mid - 1;
        else l = mid + 1;
    }
    return l;
}
int find4(int l, int r, int x) { // a[res] > x
    int mid;
    while (l <= r) {
        mid = (l + r) >> 1;
        if (a[mid] > x) r = mid - 1;
        else l = mid + 1;
    }
    return l;
}
\end{lstlisting}

\subsubsection{Trichotomy}
\begin{lstlisting}
double const eps = 1e-8;
inline double Calc(double x) {
    //...
}
double Solve(double mi, double mx) {
    double Left, Right;
    double mid, midmid;
    double midr, midmidr;
    Left = mi; Right = mx;
    while (Left + eps < Right) {
        mid = (Left + Right) / 2;
        midmid = (mid + Right) / 2;
        mid_area = Calc(mid);
        midmid_area = Calc(midmid);
        if (mid_area >= midmid_area) Right = midmid;
        else Left = mid;
    }
    return midmid_area; // or sth.
}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}


%\clearpage

\subsection{JAVA}

\subsubsection{Date}
\begin{lstlisting}[language={Java}]
SimpleDateFormat df=new SimpleDateFormat("yyyy-MM-dd EEEE",Locale.US);
while(cin.hasNext()){
    n=cin.nextInt();
    if(n==-1)break;
    GregorianCalendar wt=new GregorianCalendar(2000,Calendar.JANUARY,1);
    wt.add(GregorianCalendar.DATE, n);
    Date d=wt.getTime();
    System.out.println(df.format(d));
}
\end{lstlisting}

\subsubsection{JAVA\_IO}
\begin{lstlisting}[language={Java}]
public static String readtxt() throws IOException{
    BufferedReader br=new BufferedReader(new FileReader("d:/sql.txt"));
    String str="";
    String r=br.readLine();
    while(r!=null){
        str+=r;
        r=br.readLine();
    }
    return str;
}
\end{lstlisting}


\subsubsection{Chinese\_Theory}
\begin{lstlisting}[language={Java}]
static BigInteger[] m, r;  //mod[], a[]
static BigInteger X,Y;
static BigInteger f2(BigInteger a, BigInteger b){
	if(b.compareTo(BigInteger.ZERO)==0){
	    X = BigInteger.ONE;
	    Y = BigInteger.ZERO;
	    return a;
	}
	BigInteger d = f2(b, a.mod(b));
	BigInteger t = X;
	X = Y;
	Y = t.subtract(a.divide(b).multiply(Y));
	return d;
}
static BigInteger gcd(BigInteger a, BigInteger b){
	if(b.compareTo(BigInteger.ZERO) == 0) return a;
	else return gcd(b, a.mod(b));
}
static BigInteger f1(int len){
	int i; boolean flag = false;
	BigInteger m2,r2,d,c,t;
	BigInteger m1 = m[0], r1 = r[0];
	for(i=0;i<len-1;i++){
	    m2 = m[i+1];
	    r2 = r[i+1];
	    d = f2(m1, m2);
	    c = r2.subtract(r1);
	    if(c.mod(d).compareTo(BigInteger.ZERO) != 0){
		flag = true;
		break;
	    }
	    X = X.multiply(c).divide(d);
	    t = m2.divide(d);
	    X = (X.mod(t).add(t)).mod(t);
	    r1 = m1.multiply(X).add(r1);
	    m1 = m1.multiply(m2).divide(d);
	}
	if(flag == true){
	    return BigInteger.ZERO;
	}
	else{
	    if(r1.compareTo(BigInteger.ZERO)==0 && len > 1){
		r1 = m[0];
		for(i=1;i<len;i++)r1 = gcd(m[i],r1);
		BigInteger ans = BigInteger.ONE;
		for(i=0;i<len;i++) ans = ans.multiply(m[i]);
		r1 = ans.divide(r1);
	    }
	    if(r1.compareTo(BigInteger.ZERO)==0 && len==1) r1 = m[0];
	    return r1;
	}
}

static BigInteger lcm(BigInteger a, BigInteger b){
	return a.divide(gcd(a,b)).multiply(b);
}
static BigInteger rec(int len){
	BigInteger res = BigInteger.ONE;
	for(int i=0;i<len;i++){
	    res = lcm(res, m[i]);
	}
	return res;
}
\end{lstlisting}


\subsubsection{Matrix}
\begin{lstlisting}[language={Java}]
class Matrix {
    int n;
    BigInteger mat[][];
    void init(int k) {
        n = k + 2;
        for (int i = 0; i < k + 1; ++i) {
            mat[i][0] = BigInteger.ONE;
            for (int j = 1; j <= i; ++j) {
                mat[i][j] = mat[i - 1][j - 1].add
                            (mat[i - 1][j]);
            }
        }
        for (int j = 0; j < k + 1; ++j) {
            mat[k + 1][j] = mat[k][j];
        }
        mat[k + 1][k + 1] = BigInteger.ONE;
    }
    public Matrix() {}
    public Matrix(int n) {
        this.n = n;
        this.mat = new BigInteger[n][n];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                this.mat[i][j] = BigInteger.ZERO;
            }
        }
    }
    Matrix mul(Matrix a) {
        Matrix C = new Matrix(n);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (mat[i][j].compareTo(BigInteger.ZERO) != 0) {
                    for (int k = 0; k < n; ++k) {
                        C.mat[i][k] = C.mat[i][k].add
                                    (this.mat[i][j].multiply
                                    (a.mat[j][k]));
                    }
                }
            }
        }
        return C;
    }
    Matrix pow(BigInteger m) {
        Matrix C = new Matrix(n);
        BigInteger two = BigInteger.ONE.add( BigInteger.ONE );
        for (int i = 0; i < n; ++i) C.mat[i][i] = BigInteger.ONE;
        while (m.compareTo(BigInteger.ZERO) != 0) {
            if (m.mod(two).compareTo(BigInteger.ZERO) != 0) {
                C = C.mul(this);
            }
            Matrix T = mul(this);
            this.mat = T.mat;
            m = m.divide(two);
        }
        return C;
    }
    void print() {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                System.out.print(mat[i][j] + " ");
            }
            System.out.println();
        }
    }
}
\end{lstlisting}

//BigInteger comparator
\begin{lstlisting}[language={Java}]

Arrays.sort(arr, BigIntegerComparator.ascendingSort);

class BigIntegerComparator implements Comparator {

        // to sort in ascending order
        public static final BigIntegerComparator ascendingSort = new BigIntegerComparator(true);

        // to sort in descending order
        public static final BigIntegerComparator descendingSort = new BigIntegerComparator(false);

        // flag to handle ascending/descending mode
        private boolean isAscending;

        public int compare(Object o1, Object o2) {
                int resultFlag = 0;

                if ( (o1 instanceof BigInteger) && (o2 instanceof BigInteger)) {
                        resultFlag = ((BigInteger)o1).compareTo((BigInteger)o2);
                }

                // if we want descending we use -1 multiplier
                return (isAscending?1:-1)*resultFlag;
        }
        private BigIntegerComparator(boolean isAscending) {
                this.isAscending = isAscending;
        }
 }
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}


%\clearpage

\subsection{Geometry}

\subsubsection{Circle\_Intersection}
\begin{lstlisting}

#define Pi 3.14159265358979323846
using namespace std;
struct Circle
{
double r,x,y;
}a,b;

double distanc(Circle n,Circle m)
{
double dis=sqrt((n.x-m.x)*(n.x-m.x)+(n.y-m.y)*(n.y-m.y));
return dis;
}
double Areaone(Circle &M)
{
return M.r*M.r*Pi;
}

double Area(Circle A,Circle B)
{
double area=0.0;
Circle M=(A.r>B.r)?A:B;
Circle N=(A.r>B.r)?B:A;
double dis=distanc(M,N);
if((dis<M.r+N.r)&&(dis>M.r-N.r))
{
  double cosM1 = (M.r*M.r+dis*dis-N.r*N.r)/(2.0*M.r*dis);
  double cosN1 = (N.r*N.r+dis*dis-M.r*M.r)/(2.0*N.r*dis);
  double M1 = acos(cosM1); //arc
  double N1 = acos(cosN1);
  double TM =0.5*M.r*M.r*sin(2.0*M1); //area of tri
  double TN =0.5*N.r*N.r*sin(2.0*N1);
  double FM =(M1/Pi)*Areaone(M); //area of Fan-shaped
  double FN =(N1/Pi)*Areaone(N);
  area=FM+FN-TM-TN;
}
else if(dis<=M.r-N.r){
  area=Areaone(N);
}
return area;
}
\end{lstlisting}

\subsubsection{cal\_centre}
\begin{lstlisting}
double cal_center_x(double x1,double y1,double x2,double y2,double x3,double y3)
{
    return((y1*(y2*y2+x2*x2-y3*y3-x3*x3) - y2*(y1*y1 - y3*y3 + x1*x1 - x3*x3)
     + y3*(y1*y1-y2*y2+x1*x1-x2*x2))
     /(2*(-x1*y2 + x1*y3 + x2*y1 - x2*y3 - x3*y1 + x3*y2)));
}
double cal_center_y(double x1,double y1,double x2,double y2,double x3,double y3)
{
    return((x1*(x2*x2+y2*y2-x3*x3-y3*y3) - x2*(x1*x1 - x3*x3 + y1*y1 - y3*y3)
    + x3*(x1*x1-x2*x2+y1*y1-y2*y2))
    /(2*(-y1*x2 + y1*x3 + y2*x1 - y2*x3 - y3*x1 + y3*x2)));
}
\end{lstlisting}

\subsubsection{Line\_Intersection}
\begin{lstlisting}
const double eps=1e-8;
struct CPoint{double x,y;
}points[4],l1[2],l2[2];
int dcmp(double x){
   if(x<-eps)return -1;else return (x>eps);
}
double cross(CPoint p0,CPoint p1,CPoint p2){
   return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}
int LineIntersection(CPoint p1,CPoint p2,CPoint p3,CPoint p4,CPoint &cp){
    double u=cross(p1,p2,p3),v=cross(p2,p1,p4);
    if(dcmp(u+v)){
        cp.x=(p3.x*v+p4.x*u)/(v+u);
        cp.y=(p3.y*v+p4.y*u)/(v+u);
        return 1;
    }
    if(dcmp(u))return 2; //none
    if(dcmp(cross(p3,p4,p1)))return 3;
    return -1; //line
}
\end{lstlisting}



\subsubsection{Area of a Tetrahedron}
\begin{lstlisting}
//AB, AC, AD, CD, BD, BC.
double calc(double a, double b, double c, double r, double p, double q)
{
    a *= a, b *= b, c *= c, r *= r, p *= p, q *= q;
    double P1 = a * p * (-a + b + c - p + q + r);
    double P2 = b * q * (a - b + c + p - q + r);
    double P3 = c * r * (a + b - c + p + q - r);
    double P = a * b * r + a * c * q + b * c * p + p * q * r;
    return sqrt((P1 + P2 + P3 - P)) / 12.;
}
\end{lstlisting}


\subsubsection{crosspoint(g++ better)}
\begin{lstlisting}
#include <complex>
#define eps (1e-8)
#define x real()
#define y imag()

using namespace std;
typedef complex<double> Point;
inline int sgn(double a){ return (a > eps) - (a < -eps);}
double cross(Point a, Point b){ return imag(conj(a) * b);}
double dmul(Point a, Point b){ return real(conj(a) * b);}
bool crosspoint(Point p1, Point p2, Point q1, Point q2){
    double a = cross(p2 - p1, q2 - q1), b = cross(p2 - p1, p2 - q1);
    double c = cross(q2 - q1, p2 - p1), d = cross(q2 - q1, q2 - p1);
    if(a == 0){
        return b != 0? 0:
            (sgn(dmul(q1 - p1, q1 - p2)) <= 0 ||
                sgn(dmul(q2 - p1, q2 - p2)) <= 0);}
    else
        return (sgn(b/a) >= 0 &&
            sgn(b/a - 1) <= 0 &&
            sgn(d/c) >= 0 &&
            sgn(d/c - 1) <= 0);

  //  else return (sgn(d/c) >= 0 && sgn(d/c - 1) <= 0); cross on P
}
\end{lstlisting}

\subsubsection{N Circles cover [1-K] times}
\begin{lstlisting}
#define maxn 105
using namespace std;

double const eps = 1e-8;
double const pi = atan2(0, -1.0);
inline int sgn(double x) { return x < -eps ? -1 : x < eps ? 0 : 1; }
struct pt {
    double x, y;
    pt (double _x, double _y) { x = _x, y = _y; }
    pt () {}
    pt operator+ (const pt a) { return pt(x + a.x, y + a.y); }
    pt operator- (const pt a) { return pt(x - a.x, y - a.y); }
    pt operator* (const double r) { return pt(x * r, y * r); }
    pt operator/ (const double r) { return pt(x / r, y / r); }
    inline void print() { printf("%.2lf %.2lf\n", x, y); }
} p[maxn];
inline double xmul(const pt &a, const pt &b) {
    return a.x * b.y - a.y * b.x;
}
inline double dist(const pt &a, const pt &b) {
    return sqrt( (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) );
}


int n;
double r[maxn];


inline int rlt(int a, int b) {
	double d = dist(p[a], p[b]), d1 = sgn(d - r[a] + r[b]),
             d2 = sgn(d - r[b] + r[a]);
	if (d1 < 0 || !d1 && (d > eps || a > b))return 0;
	if (d2 < 0 || !d2 && (d > eps || a < b))return 1;
	return d < r[a] + r[b] - eps ? 2 : 3;
}

double areaArc(pt &o, double r, double ang1, double ang2) {
    pt a(o.x + r * cos(ang1), o.y + r * sin(ang1));
    pt b(o.x + r * cos(ang2), o.y + r * sin(ang2));
    double dif = ang2 - ang1;
    return (xmul(a, b) + (dif - sin(dif)) * r * r) * 0.5;
}

pair<double, int> e[maxn << 1];
double res[maxn];
int cnt;

void cal() {
    fill(res, res + n + 1, 0.0);
    double last;
    pt X, Y;
    for (int i = 0; i < n; ++i) if (r[i] > eps) {
        int acc = 0;
        cnt = 0;
        e[cnt++] = make_pair(-pi, 1);
        e[cnt++] = make_pair(pi, -1);
        for (int j = 0; j < n; ++j) if (i != j && r[j] > eps) {
            int rel = rlt(i, j);
            if (rel == 1) {
                e[cnt++] = make_pair(-pi, 1);
                e[cnt++] = make_pair(pi, -1);
            }
            else if (rel == 2) {
                double center = atan2(p[j].y - p[i].y, p[j].x - p[i].x);
		double d2 = (p[i].x - p[j].x) * (p[i].x - p[j].x) +
                    (p[i].y - p[j].y) * (p[i].y - p[j].y);
		double ang = acos((r[i] * r[i] + d2 - r[j] * r[j]) /
                    (2 * r[i] * sqrt(d2)));
		double angX = center + ang;
		double angY = center - ang;
		if (angX > pi)angX -= 2 * pi;
		if (angY < -pi)angY += 2 * pi;
				
                if (angX < angY) ++acc;
                e[cnt++] = make_pair(angX, -1);
                e[cnt++] = make_pair(angY, 1);
	    }
        }
        sort(e, e + cnt);
        last = -pi;
        for (int j = 0; j < cnt; ++j) {
            double tmp = areaArc(p[i], r[i], last, e[j].first);
            res[acc] += tmp;
            res[acc - 1] -= tmp;
            acc += e[j].second;
            last = e[j].first;
        }
    }
}
int main() {

    while (~scanf("%d", &n)) {
        for (int i = 0; i < n; ++i) {
            scanf("%lf %lf %lf", &p[i].x, &p[i].y, &r[i]);
        }
        cal();

    }
    return 0;
}
\end{lstlisting}

\subsubsection{Graham(int)}
\begin{lstlisting}
typedef __int64 ll;
struct Point {
    ll x, y;
    friend bool operator < (Point a, Point b) {
        if (a.y == b.y) return a.x < b.x;
        else return a.y < b.y;
    }
} p[maxn], res[maxn];

ll Xmul(Point a, Point b, Point c) {
    return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
}

ll Xmul(Point b, Point c) {
    return b.x * c.y - c.x * b.y;
}
int Graham(Point pnt[], int n, Point res[]) {
    int i, j, top = 1;
    sort(pnt, pnt + n);
    pnt[n] = pnt[0];
    if (n == 0) return 0; res[0] = pnt[0];
    if (n == 1) return 1; res[1] = pnt[1];
    if (n == 2) return 2; res[2] = pnt[2];
    for (i = 2; i < n; ++i) {
        while (top && Xmul(res[top - 1], res[top], pnt[i]) <= 0) --top;
        res[++top] = pnt[i];
    }
    j = top;
    res[++top] = pnt[n - 2];
    for (i = n - 3; i >= 0; --i) {
        while (top != j && Xmul(res[top - 1], res[top], pnt[i]) <= 0) --top;
        res[++top] = pnt[i];
    }
    res[top] = res[0];
    return top;
}
\end{lstlisting}

\subsubsection{Polar\_Sort(convex)}
\begin{lstlisting}
#define maxn 1005

using namespace std;
struct Point{
    int x, y;
}p[maxn];

inline int cross(Point a, Point b){
    return a.x * b.y - a.y * b.x;
}
bool cmp(Point a, Point b){
    int t = cross(a, b);
    if(t == 0){
        if(a.x * b.x < 0 || a.y * b.y < 0){
            return a.y < b.y || a.y == b.y && a.x < b.x;
        }
        else{
            return abs(a.x) < abs(b.x) || abs(a.y) < abs(b.y);
        }
    }
    else return t > 0;
}
void polar_sort(int n){
    int mx = 0, x0, y0;
    for(int i=0;i<n;i++){
        if(p[i].x < p[mx].x) mx = i;
    }
    swap(p[0], p[mx]);
    x0 = p[0].x, y0 = p[0].y;
    for(int i=0;i<n;i++){
        p[i].x -= x0;
        p[i].y -= y0;
    }
    sort(p + 1, p + n, cmp);
    for(int i=n-1;i>=0;i--){
        if(cross(p[i], p[i-1]) != 0){
            reverse(p + i, p + n);
            break;
        }
    }
    for(int i=0;i<n;i++){
        p[i].x += x0;
        p[i].y += y0;
    }
}

int main(){
    int n;
    while(~scanf("%d", &n)){
        int mx = 0, x0, y0;
        for(int i=0;i<n;i++){
            scanf("%d%d", &p[i].x, &p[i].y);
        }
        polar_sort(n);
        for(int i=0;i<n;i++){
            printf("%d %d\n", p[i].x, p[i].y);
        }
    }
    return 0;
}

\end{lstlisting}

\subsubsection{Ellipse's Circumference}
\begin{lstlisting}
double const pi = atan2(0, -1.0);

double cal(double a, double b) {
    double e2 = 1.0 - b * b / a / a;
    double e = e2;
    double ret = 1.0;
    double xa = 1.0, ya = 2.0;
    double t = 0.25;

    for (int i = 1; i <= 10000; ++i) {
        ret -= t * e;
        t = t * xa * (xa + 2) / (ya + 2) / (ya + 2);
        xa += 2.0;
        ya += 2.0;
        e *= e2;
    }
    return 2.0 * pi * a * ret;
}
int main() {
    int _ca = 1;
    double a, b;
    int T;
    for (scanf("%d", &T); T--; ) {
        scanf("%lf %lf", &a, &b);
        if (a < b) swap(a, b);
        printf("Case %d: %.10lf\n", _ca++, cal(a, b));
    }
    return 0;
}
\end{lstlisting}


\subsubsection{Area of intersection between Convex \& Circle}
\begin{lstlisting}
\\Centre of the circle (0, 0)

#define maxn 110

using namespace std;

#define sq(x) ((x) * (x))
#define sng(x) (x == 0.0? 0.0: (x > 0? 1.0: -1.0))
#define fmax(x, y) (x > y? x: y)
#define fmin(x, y) (x < y? x: y)

struct pt {
	double x, y;
	pt(double a  = 0, double b = 0)
	{
		x = a;
		y = b;
	}
	double len() { return sqrt(sq(x) + sq(y)); }
	double operator * (pt o) { return x * o.y - o.x * y; }
	double operator % (pt o) { return x * o.x + y * o.y; }
} ps[maxn];

struct sg {
	pt a, b;
	double A, B, C;
	sg(pt x, pt y)
	{
		a = x;
		b = y;
		A = a.y - b.y;
		B = b.x - a.x;
		C = -(a.y * B + a.x * A);
	}
	bool ons(pt o){
		if (fmin(a.x, b.x) <= o.x  && o.x <= fmax(a.x, b.x))
			if (fmin(a.y, b.y) <= o.y && o.y <= fmax(a.y, b.y))
				return 1;
		return 0;
	}
	double len() { return sqrt(sq(a.x - b.x) + sq(a.y - b.y)); }
	double ang() { return acos((a % b) / (a.len() * b.len())); }
	pt inr(sg o) {
		double d = (A * o.B - o.A * B);
		double x = B * o.C - o.B * C;
		double y = A * o.C - o.A * C;
		return pt(x / d, -y / d);
	}
};

double r;
int    n;

double TGL(pt a, pt b) { //Triangulate
	double sn = sng(a * b);
	if (a.len() < b.len())
		swap(a ,b);
	pt     lp(a.x - b.x, a.y - b.y), np(-lp.y, lp.x), cp;
	sg     l(a, b), nl(pt(0, 0), np);
	pt     tp = l.inr(nl);
	double tsu = 0;
	double oa = a.len();
	double ob = b.len();
	double ol = tp.len();;
	double ang, d;

	if (oa == 0.0 || oa == 0.0 || ol == 0.0)
		return 0.0;
	if (oa <= r && ob <= r)
	{
		tsu += fabs(a * b / 2.0);
	}
	else if (oa > r && ob <= r)
	{
		d = sqrt(sq(r) - sq(tp.len())) / l.len();
		tp = pt(tp.x + lp.x * d, tp.y + lp.y * d);
		ang = sg(a, tp).ang();
		tsu += ang * sq(r) / 2.0;
		tsu += fabs(tp * b/ 2.0);
	}
	else
	{
		ang = acos(ol / r);
		tsu += l.ang() * sq(r) / 2.0;
		if (oa > r && ob > r && ol < r && l.ons(tp))
			tsu += ol * r * sin(ang) - ang * sq(r);
	}

	return tsu * sn;
}

int main() {
	int i;
	double tsu;

	while (scanf("%lf", &r) != EOF)
	{
		scanf("%d", &n);
		for (i = 0; i < n; i++)
			scanf("%lf%lf", &ps[i].x, &ps[i].y);
		tsu = 0.0;
		for (i = 0; i < n; i++)
			tsu += TGL(ps[i], ps[(i + 1) % n]);
		printf("%.2lf\n", fabs(tsu));
	}

	return 0;
}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}


%\clearpage

\subsection{Others}
\begin{lstlisting}
//BigNum
/*
  Duze liczby z ustalana podstawa
*/

typedef unsigned long long digit;

#define MAX_DIGIT 1000000000
#define MAX_LENGTH 9 // MAX_DIGIT=10^MAX_LENGTH

class BigNum {
  vector<digit> data;

  void shrink() {
    while (data.size()>1 && !data[data.size()-1])
      data.resize(data.size()-1);
  }

  public:
    BigNum(digit i=0) {
      data.resize(1,i%MAX_DIGIT);
      i/=MAX_DIGIT;
      while (i) {
        data.resize(data.size()+1);
        data.back()=i%MAX_DIGIT;
        i/=MAX_DIGIT;
      }
    }

    explicit BigNum(const char *t) {
      int n=0,i,j,k;
      while (t[n])
        n++;
      for (i=n-1; i>=0; i-=MAX_LENGTH) {
        k=0;
        for (j=MAX_LENGTH-1; j>=0; j--)
          if (i-j>=0)
            k=10*k+t[i-j]-'0';
        data.push_back(k);
      }
      shrink();
    }

    BigNum &operator--() {
      int i=0;
      while (!data[i]) {
        data[i]=MAX_DIGIT-1;
        i++;
      }
      data[i]--;
      return *this;
    }

    BigNum &operator++() {
      int i=0;
      while (data[i]+1==MAX_DIGIT) {
        data[i]=0;
        i++;
      }
      data[i]++;
      return *this;
    }

    BigNum &operator+=(const BigNum &a) {
      digit i=0,p=0;
      while (p || i<data.size() || i<a.data.size()) {
        if (i<data.size())
          p+=data[i];
        if (i<a.data.size())
          p+=a.data[i];
        if (i>=data.size())
          data.resize(i+1);
        if (p>=MAX_DIGIT) {
          data[i]=p-MAX_DIGIT;
          p=1;
        }
        else {
          data[i]=p;
          p=0;
        }
        i++;
      }
      return *this;
    }

    BigNum &operator-=(const BigNum &a) {
      digit p=0;
      for (int i=0; i<data.size() || p; i++) {
        if (i<a.data.size())
          p+=a.data[i];
        if (p<=data[i]) {
          data[i]-=p;
          p=0;
        }
        else {
          data[i]+=MAX_DIGIT-p;
          p=1;
        }
      }
      shrink();
      return *this;
    }

    BigNum operator+(BigNum a) {
      BigNum r=*this;

      r+=a;
      return r;
    }

    BigNum operator-(BigNum a) {
      BigNum r=*this;

      r-=a;
      return r;
    }

    digit operator%(digit d) {
      digit p=0;
      for (int i=data.size()-1; i>=0; i--)
        p=(p*MAX_DIGIT+data[i])%d;
      return p;
    }

    BigNum operator*(const BigNum &a) {
      BigNum r;
      if(zero()||a.zero())return r;
      for (int i=0; i<data.size(); i++) {
        BigNum t=a;
        t*=data[i];
        t.data.resize(t.data.size()+i);
        for (int j=t.data.size()-i-1; j>=0; j--)
          t.data[j+i]=t.data[j];
        for (int j=0; j<i; j++)
          t.data[j]=0;
        r+=t;
      }
      r.shrink();
      return r;
    }

    BigNum operator/(BigNum a) {
      BigNum ans,t=*this,power=1,ta=a;

      while (ta<t) {
        power*=10;
        ta*=10;
      }
      while (!power.zero()) {
        while (ta<t || ta==t) {
          ans+=power;
          t-=ta;
        }
        power/=10;
        ta/=10;
      }
      return ans;
    }

    BigNum operator%(BigNum a) {
      return *this-(*this/a)*a;
    }

    BigNum &operator*=(digit m) {
      digit p=0;
      for (int i=0; p || i<data.size(); i++) {
        if (i<data.size())
          p+=m*data[i];
        if (i>=data.size())
          data.resize(i+1);
        data[i]=p%MAX_DIGIT;
        p/=MAX_DIGIT;
      }
      return *this;
    }

    BigNum &operator/=(digit d) {
      digit p=0;
      for (int i=data.size()-1; i>=0; i--) {
        p=p*MAX_DIGIT+data[i];
        data[i]=p/d;
        p%=d;
      }
      shrink();
      return *this;
    }

    bool operator==(const BigNum &x) const {
      if (data.size()!=x.data.size())
        return false;
      int i=0;
      while (i<data.size() && data[i]==x.data[i])
        i++;
      return i==data.size();
    }

    bool operator<(const BigNum &x) const {
      if (x.data.size()!=data.size())
        return data.size()<x.data.size();
      int i=data.size()-1;
      while (i>=0 && data[i]==x.data[i])
        i--;
      return i>=0 && data[i]<x.data[i];
    }

    bool zero() const {
      return data.size()==1 && !data[0];
    }

    friend ostream &operator<<(ostream &out,const BigNum &a) {
      out<<a.data[a.data.size()-1];
      for (int i=a.data.size()-2; i>=0; i--) {
        digit j=a.data[i]+!a.data[i];
        while (j<MAX_DIGIT/10) {
          out<<0;
          j=j*10;
        }
       out<<a.data[i];
      }
      return out;
    }
};

struct euclid_result {
  BigNum alfa,beta,d;
  bool beta_negative;
  euclid_result(BigNum _alfa,BigNum _beta,BigNum _d,bool _beta_negative) {
    alfa=_alfa; beta=_beta; d=_d; beta_negative=_beta_negative;
  }
};

euclid_result extended_euclid(BigNum a,BigNum b) {
  if (b.zero())
    return euclid_result(1,0,a,true);
  euclid_result r=extended_euclid(b,a%b);
  // d=alfa*b+a%b*beta=a*beta+(-a/b+alfa)*b
  return euclid_result(r.beta,r.alfa+(a/b)*r.beta,r.d,!r.beta_negative);
}

BigNum inverse(BigNum a,BigNum m) {
  euclid_result r=extended_euclid(a,m);
  if (r.beta_negative)
    return r.alfa%m;
  else {
    return (m-r.alfa%m)%m;
  }
}
int main(){
    return 0;
}
\end{lstlisting}

\subsubsection{BigNum}
\begin{lstlisting}
//bignum_uestc
const int maxleng=50;

class BigInt
{
public:
        int leng;
        int num[maxleng];
public:
        BigInt()
        {
                leng=1;
                memset(num,0,sizeof(num));
        }
        BigInt(int x)
        {
                leng=0;
                memset(num,0,sizeof(num));
                while(x)
                {
                        num[leng++]=x%10000;
                        x/=10000;
                }
                if(leng==0)leng=1;
        }
        operator int()
        {
                int x=0,l=leng-1;
                while(l>=0)
                {
                        x=x*10000+num[l];
                        l--;
                }
                return x;
        }
        operator int*()
        {
                return num;
        }
        int length()
        {
                return leng;
        }
        void read()
        {
                char s[maxleng+1];
                scanf("%s",s);
                int l=strlen(s);
                leng=0;
                for(int i=l-1;i>=0;)
                {
                        if(i>=0)num[leng]+=(s[i--]-'0');
                        if(i>=0)num[leng]+=(s[i--]-'0')*10;
                        if(i>=0)num[leng]+=(s[i--]-'0')*100;
                        if(i>=0)num[leng]+=(s[i--]-'0')*1000;
                        leng++;
                }
                if(leng==0)leng=1;
        }
        void write()
        {
                int i=leng-1;
                printf("%d",num[i]);i--;
                while(i>=0)printf("%04d",num[i--]);
        }
        void writeln()
        {
                write();
                printf("\n");
        }
        void getlength()
        {
                leng=maxleng-1;
                while(num[leng]==0&&leng>0)leng--;
                leng++;
        }
        friend BigInt operator+(BigInt a,BigInt b);
        friend BigInt operator+(BigInt a,int b);
        friend BigInt operator-(BigInt a,BigInt b);
        friend BigInt operator*(BigInt a,BigInt b);
        friend BigInt operator*(BigInt a,int b);
        friend BigInt operator/(BigInt a,BigInt b);
        friend bool operator<(BigInt a,BigInt b);
};

BigInt operator+(BigInt a,BigInt b)
{
        int l=a.leng>b.leng?a.leng:b.leng,t=0;
        BigInt ans;
        for(int i=0;i<l;i++)
        {
                ans[i]=(a[i]+b[i]+t)%10000;
                t=(a[i]+b[i]+t)/10000;
        }
        while(t)
        {
                ans[l++]=t%10000;
                t/=10000;
        }
        ans.leng=l;
        return ans;
}

BigInt operator+(BigInt a,int b)
{
        int t=0;
        BigInt ans;
        memcpy(ans.num,a.num,sizeof(a.num));
        ans[t]+=b;
        while(a[t]>=10000)
        {
                ans[t+1]+=ans[t]/10000;
                ans[t]%=10000;
        }
        ans.getlength();
        return ans;
}

//a >= b
BigInt operator-(BigInt a,BigInt b)
{
        int l=a.leng;
        BigInt ans;
        memcpy(ans.num,a.num,sizeof(a.num));
        for(int i=0;i<l;i++)
        {
                ans[i]-=b[i];
                if(ans[i]<0)
                {
                        ans[i]+=10000;
                        ans[i+1]--;
                }
        }
        ans.getlength();
        return ans;
}

BigInt operator*(BigInt a,BigInt b)
{
        int la=a.leng,lb=b.leng,t,p;
        BigInt ans;
        for(int i=0;i<la;i++)
        {
                t=0;
                for(int j=0;j<lb;j++)
                {
                        p=(ans[i+j]+a[i]*b[j]+t)/10000;
                        ans[i+j]=(ans[i+j]+a[i]*b[j]+t)%10000;
                        t=p;
                }
                p=i+lb;
                if(t)
                {
                        ans[p]+=t;
                        while(ans[p]>=10000)
                        {
                                ans[p+1]+=ans[p]/10000;
                                ans[p]%=10000;
                                p++;
                        }
                }
        }
        ans.getlength();
        return ans;
}

BigInt operator*(BigInt a,int b)
{
        int t=0,p=a.leng;
        BigInt ans;
        for(int i=0;i<p;i++)
        {
                ans[i]=(a[i]*b+t)%10000;
                t=(a[i]*b+t)/10000;
        }
        while(t)
        {
                ans[p++]=t%10000;
                t/=10000;
        }
        ans.getlength();
        return ans;
}

bool operator<(BigInt a,BigInt b)
{
        if(a.leng!=b.leng)return a.leng<b.leng;
        for(int i=a.leng-1;i>=0;i--)
                if(a[i]!=b[i])return a[i]<b[i];
        return false;
}
\end{lstlisting}

\subsubsection{calculator}
\begin{lstlisting}
#define maxn 111
using namespace std;
struct node {
    int t; // t = 0 : num; t = 1 : operator.
    int value; // for op: +-*/()#^? == 012345678
    node (int _t, int _v) { t = _t, value = _v; }
    node () {}
} p[maxn];
char opt[] = "+-*/()#^?";
int omp[128];
int ask[13], asn;
int scan(char *str) {
    for (int i = 0; i < 9; ++i) omp[ opt[i] ] = i;
    int len = strlen(str);
    int cnt = 0, idx = 0, val;

    char op;
    asn = 0;
    for (idx = 0 ;idx < len; ) {
        if ( isdigit(str[idx]) ) {
            sscanf(str + idx, "%d", &val);
            p[cnt++] = node(0, val);
            while ( isdigit(str[idx]) ) ++idx;
        }
        else {
            sscanf(str + idx, "%c", &op);
            if (op == '?') ask[asn++] = cnt;
            p[cnt++] = node(1, omp[op]);
            ++idx;
        }
    }
    return cnt;
}

const int prior[8][8] =  {
//    +   -   *   /   (   )   #   ^
    { 1,  1, -1, -1, -1,  1,  1, -1}, // +
    { 1,  1, -1, -1, -1,  1,  1, -1}, // -
    { 1,  1,  1,  1, -1,  1,  1, -1}, // *
    { 1,  1,  1,  1, -1,  1,  1, -1}, // /
    {-1, -1, -1, -1, -1,  0, -2, -1}, // (
    { 1,  1,  1,  1, -2,  1,  1,  1}, // )
    {-1, -1, -1, -1, -1, -2,  0, -1}, // #
    { 1,  1,  1,  1, -1,  1,  1,  1}  // ^
};


inline char chg(int c){
    char mp[] = "+-*/()#^";
    return mp[c];
}
struct Calculator{


    inline int atos(char* s){
        return atoi(s);
    }

    inline int operate(int a, int c, int b){
        switch (c) {
            case 0: return a + b;
            case 1: return a - b;
            case 2: return a * b;
            case 3: if(b == 0) return -inf;
                      else return a / b;
            default:  return -1;
        }
    }

    int OPTR[maxn];
    int OPND[maxn];
    int calculate(int cnt){

        int lr = 0, ld = 0;
        OPTR[++lr] = 6;

        int idx = 0;

        int a, b, c;
        for (int i = 0; i < cnt; ++i) {
            if (p[i].t == 0) OPND[++ld] = p[i].value;
            else {
                switch (prior[OPTR[lr]][p[i].value]) {
                    case -1: OPTR[++lr] = p[i].value;
                             break;
                    case  0: lr--;
                             break;
                    case  1: c = OPTR[lr--];
                             b = OPND[ld--];
                             a = OPND[ld--];
                             //cout << lr << ":" << a << chg(c) << b <<endl;
                             OPND[++ld] = (operate(a, c, b));
                             if (OPND[ld] == -inf) return -inf;
                             --i;
                             break;
                }
            }
        }

        return OPND[ld];
    }
}cal;
\end{lstlisting}

\subsubsection{Largest Submatrix of All 1's}
\begin{lstlisting}
int n, m;
bool mp[maxn][maxn];

int h[maxn][maxn];
int l[maxn], r[maxn];

int cal() {
    for (int i = 1; i <= n; ++i) {
        h[i][m + 1] = 0;
        for (int j = m; j >= 1; --j) {
            if (!mp[i][j]) h[i][j] = 0;
            else h[i][j] = h[i][j + 1] + 1;
        }
    }

    int ret = 0;
    int x1, y1, x2, y2;
    for (int j = 1; j <= m; ++j) {
        h[0][j] = h[n + 1][j] = -1;
        for (int i = 1; i <= n; ++i) {
            l[i] = i;
            while (h[l[i] - 1][j] >= h[i][j]) {
                l[i] = l[l[i] - 1];
            }
        }
        for (int i = n; i >= 1; --i) {
            r[i] = i;
            while (h[r[i] + 1][j] >= h[i][j]) {
                r[i] = r[r[i] + 1];
            }
        }
        for (int i = 1; i <= n; ++i) {
            x1 = l[i], x2 = r[i], y1 = j, y2 = j + h[i][j] - 1;
            ret = max(ret, (x2 - x1 + 1) * (y2 - y1 + 1));
        }
    }
    return ret;
}
\end{lstlisting}

\subsubsection{xor from 1 to n}
\begin{lstlisting}
int xor_n(int n) {
     int t = n & 3;
     if (t & 1) return t / 2 ^ 1;
     return t / 2 ^ n;
}
\end{lstlisting}

\subsubsection{(DP) Find kth number contains 666}
\begin{lstlisting}

#define inf 0x3f3f3f3f
#define Inf 0x3FFFFFFFFFFFFFFFLL
#define maxn 20
using namespace std;
typedef __int64 ll;
int num[maxn], m;
ll dp[maxn][4];

int dfs(int pos, int state, bool flag) {
    if(pos == -1) return state == 3;
    if(!flag && dp[pos][state] != -1) return dp[pos][state];
    int end = flag ? num[pos] : 9;
    ll ret = 0;
    for (int i = 0; i <= end; ++i) {
        if(state == 3) ret += dfs(pos - 1, 3, flag && i == end);
        else ret += dfs(pos - 1, (i == 6)? state + 1 : 0, flag && i == end);
    }
    if(!flag) dp[pos][state] = ret;
    return ret;
}

void init(ll n) {
    m = 0;
    for (; n; n /= 10) num[m++] = n % 10;
    num[m] = 0;
    memset(dp, 0xff, sizeof dp);
    dfs(m - 1, 0, true);
}

ll ans;

void find(int pos, int state, ll now, int k, bool flag) {
    if(pos == -1) {
        if(state == 3) ans = now;
        return;
    }
    int end = flag ? num[pos] : 9;
    int p, t;
    for (p = 0; p <= end; ++p) {
        if(state == 3) t = dfs(pos - 1, 3, flag && p == end);
        else t = dfs(pos - 1, (p == 6) ? state + 1 : 0, flag && p == end);
        if(t < k) k -= t;
        else break;
    }
    if(state == 3) find(pos - 1, 3, now * 10 + p, k, flag && p == end);
    else find(pos - 1, (p == 6) ? state + 1 : 0, now * 10 + p, k, flag && p == end);
}

int main(){
    init(10000000000LL);
    int T, k;
    for (scanf("%d", &T); T--; ) {
        scanf("%d", &k);
        find(m, 0, 0, k, true);
        printf("%I64d\n", ans);
    }
    return 0;
}
\end{lstlisting}

\subsubsection{DLX}
\begin{lstlisting}
int const maxn = 1010;
int const maxi = maxn * maxn + maxn;
int U[maxi], D[maxi], L[maxi], R[maxi], C[maxi], W[maxi];
int S[maxn], O[maxn];
int n, m, K;

inline void remove(int c) {
	L[R[c]] = L[c];
	R[L[c]] = R[c];
	for (int i = D[c]; i != c; i = D[i]) {
		for (int j = R[i]; j != i; j = R[j]) {
			U[D[j]] = U[j];
			D[U[j]] = D[j];
			S[C[j]]--;
		}
	}
}
inline void resume(int c) {
	for (int i = U[c]; i != c; i = U[i]) {
		for (int j = L[i]; j != i; j = L[j]) {
			S[C[j]]++;
			U[D[j]] = D[U[j]] = j;
		}
	}
	L[R[c]] = R[L[c]] = c;
}
bool dfs() {
	if (R[0] == 0) return true;
	int s = inf, c;
	for (int t = R[0]; t != 0; t = R[t]) {
		if (S[t] < s) {
			s = S[t];
			c = t;
		}
	}
	remove(c);
	for (int i = D[c]; i != c; i = D[i]) {
		O[K] = W[i];
		for (int j = R[i]; j != i; j = R[j]) {
			remove(C[j]);
		}
		++K;
		if (dfs()) return true;
		--K;
		for (int j = L[i]; j != i; j = L[j]) {
			resume(C[j]);
		}
	}
	resume(c);
	return false;
}
int mp[maxn][maxn], d[maxn];
int idx;

int main() {
	while (~scanf("%d%d", &n, &m)) {
		for (int i = 1; i <= n; ++i) {
			scanf("%d", &d[i]);
			for (int j = 0; j < d[i]; ++j) {
				scanf("%d", &mp[i][j]);
			}
			sort(mp[i], mp[i] + d[i]);
		}
		memset(S, 0, sizeof S);
		idx = 0;
		L[0] = m, R[0] = 1;
		for (int i = 1; i <= m; ++i) {
			L[i] = i - 1;
			R[i] = i + 1;
			U[i] = D[i] = i;
		}
		R[m] = 0;
		idx = m + 1;
		for (int i = 1; i <= n; ++i) {
			int s = idx, c;
			L[s] = R[s] = s;
			for (int j = 0; j < d[i]; ++j) {
				c = mp[i][j];
				S[c]++;
				W[idx] = i;
				C[idx] = c;
				U[idx] = U[c]; D[idx] = c; D[U[c]] = idx; U[c] = idx;
				L[idx] = L[s]; R[idx] = s; R[L[s]] = idx; L[s] = idx;
				++idx;
			}
		}
		K = 0;
		bool flag = dfs();
		if (!flag) puts("NO");
		else {
			printf("%d ", K);
			for (int i = 0; i < K; ++i) {
				if (i == K - 1) printf("%d\n", O[i]);
				else printf("%d ", O[i]);
			}
		}
		
	}
	return 0;
}
\end{lstlisting}

\lstset{
    showstringspaces=false,
}


\subsubsection{vimrc}
\begin{lstlisting}
behave mswin
vnoremap <C-X> "+x
vnoremap <C-C> "+y
map <C-V> "+gP
cmap <C-V> <C-R>+
exe 'inoremap <script> <C-V>' paste#paste_cmd['i']
exe 'vnoremap <script> <C-V>' paste#paste_cmd['v']
noremap <C-S> :update<CR>
inoremap <C-S> <C-O>:update<CR>
noremap  <C-A> gggH<C-O>G
inoremap <C-A> <C-O>gg<C-O>gH<C-O>G
inoremap <C-D> <C-O>dd
noremap  <C-Z> u
inoremap <C-Z> <C-O>u
map <F3> 0i//<C-C>
map <F4> ^xx
inoremap <CR> <CR><space><bs>
nnoremap o o<space><bs>
nnoremap O O<space><bs>
noremap <F6> =a{
inoremap { {<c-c>==+?{<cr>a
inoremap } }<c-c>==+?}<cr>a
au GUIEnter * simalt ~x
cd F:\vim
syn on
colo torte
se lines=40 co=130 cb+=unnamed nu sw=4 ts=4 nobk cin nocp mouse=a bs=2 hi=50  gfn=Courier_New:h12:cANSI
map <c-t> :tabnew<CR>
map <tab> :tabn<CR>
map <s-tab> :tabp<CR>
map <c-w> :close<cr>
inoremap <F10> <C-C>:call CR()<CR>
map <F10> :call CR()<CR>
func CR()
exec "w"
exec "!start cmd /c g++ %<.cc -o %<.exe & %<.exe < %<.in & pause"
endfunc

inoremap <F9> <C-C>:call CR2()<CR>
map <F9> :call CR2()<CR>
func CR2()
exec "w"
exec "!start cmd /c g++ %<.cc -o %<.exe & %<.exe & pause"
endfunc

inoremap <F2> <C-C>:call CR3()<CR>
map <F2> :call CR3()<CR>
func CR3()
exec "vsplit"
exec "vi %<.in"
endfunc

inoremap <F5> <C-C>:call SetTitle()<CR> GkkO
map <F5> :call SetTitle()<CR> GkkO
func SetTitle()
call setline(1, "#include <iostream>")
call append(line("."), "#include <cstdio>")
call append(line(".")+1, "#include <cstdlib>")
call append(line(".")+2, "#include <cstring>")
call append(line(".")+3, "#include <algorithm>")
call append(line(".")+4, "#include <cmath>")
call append(line(".")+5, "#include <string>")
call append(line(".")+6, "#include <vector>")
call append(line(".")+7, "#include <queue>")
call append(line(".")+8, "#include <set>")
call append(line(".")+9, "#include <map>")
call append(line(".")+10, "#include <ctime>")
call append(line(".")+11, "")
call append(line(".")+12, "#define inf 0x3f3f3f3f")
call append(line(".")+13, "#define Inf 0x3FFFFFFFFFFFFFFFLL")
call append(line(".")+14, "using namespace std;")
call append(line(".")+15, "")
call append(line(".")+16, "int main() {")
"call append(line(".")+17, "    freopen(\"".expand("%<:t").".in\", \"r\", stdin);")
call append(line(".")+17, "    return 0;")
call append(line(".")+18, "}")
call append(line(".")+19, "")
endfunc



nmap <C-F> <Esc>:Setcomment<CR>
imap <C-F> <Esc>:Setcomment<CR>
vmap <C-F> <Esc>:SetcommentV<CR>
command! -nargs=0 Setcomment call s:SET_COMMENT()
command! -nargs=0 SetcommentV call s:SET_COMMENTV()

"non visual
function! s:SET_COMMENT()
    let lindex=line(".")
    let str=getline(lindex)
    let CommentMsg=s:IsComment(str)
    call s:SET_COMMENTV_LINE(lindex,CommentMsg[1],CommentMsg[0])
endfunction

"visual
function! s:SET_COMMENTV()
    let lbeginindex=line("'<")
    let lendindex=line("'>")
    let i=lbeginindex
    while i<=lendindex
	let str=getline(i)
	let CommentMsg=s:IsComment(str)
        call s:SET_COMMENTV_LINE(i,CommentMsg[1],CommentMsg[0])
        let i=i+1
    endwhile
endfunction

function! s:SET_COMMENTV_LINE( index,pos, comment_flag )
    let poscur = [0, 0,0, 0]
    let poscur[1]=a:index
    let poscur[2]=a:pos+1
    call setpos(".",poscur)

    if a:comment_flag==0
        exec "normal! i//
    else
        exec "normal! xx"
    endif
endfunction

function! s:IsComment(str)
    let ret= [0, 0]
    let i=0
    let strlen=len(a:str)
    while i<strlen
        if !(a:str[i]==' ' ||    a:str[i] == '	' )
            let ret[1]=i
            if a:str[i]=='/' && a:str[i+1]=='/'
                let ret[0]=1
            else
                let ret[0]=0
            endif
            return ret
        endif
        let i=i+1
    endwhile
    return [0,0]
endfunction


"set guifont=Consolas\ 12

inoremap ( ()<Esc>i
inoremap [ []<Esc>i
inoremap { {<CR>}<Esc>O
autocmd Syntax html,vim inoremap < <lt>><Esc>i| inoremap > <c-r>=ClosePair('>')<CR>
inoremap ) <c-r>=ClosePair(')')<CR>
inoremap ] <c-r>=ClosePair(']')<CR>
inoremap } <c-r>=CloseBracket()<CR>
inoremap " <c-r>=QuoteDelim('"')<CR>
inoremap ' <c-r>=QuoteDelim("'")<CR>

function ClosePair(char)
 if getline('.')[col('.') - 1] == a:char
 return "\<Right>"
 else
 return a:char
 endif
endf

function CloseBracket()
 if match(getline(line('.') + 1), '\s*}') < 0
 return "\<CR>}"
 else
 return "\<Esc>j0f}a"
 endif
endf

function QuoteDelim(char)
 let line = getline('.')
 let col = col('.')
 if line[col - 2] == "\\"
 "Inserting a quoted quotation mark into the string
 return a:char
 elseif line[col - 1] == a:char
 "Escaping out of the string
 return "\<Right>"
 else
 "Starting a string
 return a:char.a:char."\<Esc>i"
 endif
endf

colors vividchalk

if has('gui_running')
  set guifont=Consolas:h11
endif

set ofu=syntaxcomplete#Complete
imap <silent> ` <C-X><C-O>
\end{lstlisting}

\end{flushleft}
\clearpage
%\end{tabular}
\end{multicols}

 \newpage

\end{CJK*}
\end{document}
