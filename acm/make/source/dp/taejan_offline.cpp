`所谓离线算法，是指首先读入所有的询问（求一次LCA 叫做一次询问），然后重新组织查询处理顺序以便得到更高效的处理方法。\\
Tarjan 算法是一个常见的用于解决 LCA 问题的离线算法，它结合了深度优先遍历和并查集，整个算法为线性处理时间。\\
Tarjan 算法是基于并查集的，利用并查集优越的时空复杂度，可以实现 LCA 问题的 O(n+Q)算法，这里 Q表示询问 的次数。\\
同上一个算法一样，Tarjan 算法也要用到深度优先搜索，算法大体流程如下：\\
对于新搜索到的一个结点，首先创建由这个结点构成的集合，再对当前结点的每一个子树进行搜索，每搜索完一棵子树，则可确定子树内的 LCA 询问都已解决。\\
其他的 LCA 询问的结果必然在这个子树之外，这时把子树所形成的集合与当前结点的集合合并，并将当前结点设为这个集合的祖先。\\
之后继续搜索下一棵子树，直到当前结点的所有子树搜索完。\\
这时把当前结点也设为已被检查过的，同时可以处理有关当前结点的 LCA 询问，如果有一个从当前结点到结点 v 的询问，且 v 已被检查过，则由于进行的是深度优先搜索，当前结点与 v 的最近公共祖先一定还没有被检查，而这个最近公共祖先的包涵 v 的子树一定已经搜索过了，那么这个最近公共祖先一定是 v 所在集合的祖先。`

//`代码实现`

int id[N];//初始化-1
int lcs[N][N],
int g[N][N];//邻接矩阵
int get(int i) {
    if (id[i] == i) return i;
    return id[i] = get(id[i]);
}
void unin(int i, int j) {
    id[get(i)] = get(j);
}
void dfs(int rt, int n) {
    int i;
    id[rt] = rt;
    for (i = 0; i < n; ++i) if (g[rt][i] && -1 == id[i]) {
            dfs(i, n);
            unin(i, rt);
        }
    for (i = 0; i < n; ++i) if (-1 != id[i])
            lcs[rt][i] = lcs[i][rt] = get(i);
}
 
