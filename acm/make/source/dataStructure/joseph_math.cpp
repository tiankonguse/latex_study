`问题描述：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号。`

`我们知道第一个人(编号一定是(m-1)%n) 出列之后，剩下的n-1个人组成了一个新的约瑟夫环（以编号为k=m%n的人开始）:\\
  k k+1 k+2 ... n-2, n-1, 0, 1, 2, ... k-2\\
  并且从k开始报0。\\
  现在我们把他们的编号做一下转换：\\
  序列1： 1, 2, 3, 4, …, n-2, n-1, n\\
  序列2： 1, 2, 3, 4, … k-1, k+1, …, n-2, n-1, n\\
  序列3： k+1, k+2, k+3, …, n-2, n-1, n, 1, 2, 3,…, k-2, k-1\\
  序列4：1, 2, 3, 4, …, 5, 6, 7, 8, …, n-2, n-1\\
  变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情况的解吗？！！变回去的公式很简单，相信大家都可以推出来(其实就是利用子问题的解等价转换人数等于n的解,因为n在转化成n-1时已经出队一个人了,剩下n-1的最后出队人仍然和n的解相同,只是需要映射将下标到人数为n的情况)：\\
  ∵ k=m\%n;\\
  ∴ x' = x+k = x+ m\%n ; 而 x+ m\%n 可能大于n\\
  ∴x'= (x+ m\%n)%n = (x+m)\%n\\
  得到 x‘=(x+m)\%n\\
  如何知道(n-1)个人报数的问题的解？对，只要知道(n-2)个人的解就行了。(n-2)个人的解呢？当然是先求(n-3)的情况 ---- 这显然就是一个倒推问题！好了，思路出来了，下面写递推公式：\\
  令f表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n].\\
  递推公式:\\
  f[1]=0;\\
  f[i]=(f[i-1]+m)\%i; (i>1)\\
  有了这个公式，我们要做的就是从1-n顺序算出f的数值，最后结果是f[n]。因为实际生活中编号总是从1开始，我们输出f[n]+1由于是逐级递推，不需要保存每个f，程序也是异常简单：\\
`
int getAns(int n,int m){
    int ans = 0;
    for (int i=2; i<=n; i++){
        ans=(ans+m)%i;
    }
    return ans+1;
}
